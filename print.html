<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Network Analysis and Data Integration (NADI)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Network Analysis and Data Integration (NADI)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<div class="warning">
NADI is currently under active development. As such does not have stable API
yet, and many of the concepts explained in this book might not work
yet.
<p>If you still want to use it for your projects, please do them with the
knowledge that the API might change in next versions, and you might
have to keep it updated until the system is stable. If you have any
problems with the program, or would like some new features, please
make an github issue, we will try to accomodate it if it fits within
the scope of the program.</p>
</div>
<p><a href="./data/nadi-book.pdf">The PDF version of this book (Experimental)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h1>
<p>Thank you everyone who has been consistently testing this software throughout the development and providing feedbacks. Specially the members of Water System Analysis Lab in University of Cincinnati.</p>
<h1 id="funding"><a class="header" href="#funding">Funding</a></h1>
<p>Grant: #W912HZ-24-2-0049 Investigators: Ray, Patrick 09-30-2024 – 09-29-2025 U.S. Army Corps of Engineers Advanced Software Tools for Network Analysis and Data Integration (NADI) 74263.03 Hold Level:Federal</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-nadi-system"><a class="header" href="#what-is-nadi-system">What is NADI System?</a></h1>
<p>Network Analysis amd Data Integration (NADI) System is a system of programs made to make network based data analysis easier and more accessible.</p>
<p>It consists of multiple tools, that perform two important functions, network detection and network analysis. First part is done throuh the <strong>Geographic Information (GIS) Tool</strong>, while the second part is done using a <strong>Domain Specific Programming Language (DSPL)</strong> called NADI Task system.</p>
<p><img src="./images/nadi-workflow-simple.svg" alt="Nadi Workflow" /></p>
<h1 id="why-use-nadi-system"><a class="header" href="#why-use-nadi-system">Why use NADI System?</a></h1>
<p>Hydrologic modeling involves the integration of diverse data to
simulate complex (and often poorly understood) hydrological
processes. The analysis of complex hydrological processes often
requires using domain specific calculations, and the visual
representation requires the creation of custom maps and plots. Both of
which can be a repetitive and error-prone processes, diverting time
from data interpretation and scientific inquiry. Efficient methods are
needed to automate these tasks, allowing researchers to focus on
higher-level analysis and translation of their findings.</p>
<p>Current solution to that problem is to either use general purpose programming languages like Python, R, Julia, etc., or use domain specific software packages to increase the reliability of the tasks. Domain Specific Programming Languages (DSPLs) like the NADI Task system provides better syntax for domain specific tasks, while also are general purpose enough for users to extend it for their use cases. NADI System is trying to be the software framework that can connect those two by integrating with various softwares and providing a intuitive way to do network based data analysis.</p>
<p>Some example functionality of NADI system includes:</p>
<ul>
<li>Detection of upstream/downstream relationships from stream network,</li>
<li>Network based programming using an extensible custom programming language,</li>
<li>Interactive plots and reports generation,</li>
<li>Import/export from/to various GIS data formats, etc.</li>
</ul>
<h2 id="network-based-data-analysis"><a class="header" href="#network-based-data-analysis">Network Based Data Analysis</a></h2>
<p>If you have data that are network based, like in case of data related to points in a river. NADI provides a text representation of the network that can be manually created with any text editor, or through NADI GIS tool.</p>
<!-- TODO -->
<!-- ## Interactive outputs -->
<!-- Here is a sample interactive plot made using NADI. -->
<!-- ```task run svg -->
<!-- ``` -->
<h2 id="task-system"><a class="header" href="#task-system">Task System</a></h2>
<p>The Domain Specific Programming Language (DSPL) developed for network analysis in NADI makes network analysis simple and intutive. So, it is easier to understand, interpret and catch mistakes. While the NADI IDE has network visualization tools built in that can help you visualiza the network attributes for visual analysis.</p>
<p>For example, implementing “cumulative sum of streamflow” in nadi:</p>
<pre><code class="language-task">node&lt;inputsfirst&gt;.cum_sf = node.streamflow + sum(inputs.streamflow);
</code></pre>
<p>The trying to do this in Python while making sure input nodes are run before the output. So you might have to write a recursive algorithm like this:</p>
<pre><code class="language-python">def cum_sf(node):
	node.cum_sf = node.streamflow + sum([cum_sf(i) for i in node.inputs()])
	return node.cum_sf

cum_sf(network.outlet())
</code></pre>
<p>While a common mistake people might make is to write a simple loop like this:</p>
<pre><code class="language-python">for node in network.nodes():
    node.cum_sf = node.streamflow + sum(
	    [i.streamflow for i in node.inputs()]
	)
</code></pre>
<p>Which doesn’t make sure input nodes are run before output in this case, and can error out when some variables are not present. NADI provides special syntax for cases where you can make sure variables exist before running something.</p>
<h2 id="extensibility"><a class="header" href="#extensibility">Extensibility</a></h2>
<p>NADI has two types of plugin systems, which means users can write their own analysis in any programming language and have it interact with NADI through attributes, or they can write it in rust and have even more direct interaction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who this book is for</a></h1>
<p>This book has sections explaining the concepts of the NADI system, its developmental notes, user guide and developer guide.</p>
<p>Hence it can be useful for people who:</p>
<ul>
<li>Want to understand the concepts used in NADI,</li>
<li>Want to use NADI system for their use case,</li>
<li>Want to develop plugin system for NADI,</li>
<li>Want to contribute to the NADI system packages, etc.</li>
</ul>
<p>Although not intended, it might include resources and links to other materials related to Rust concepts, Geographical Information System (GIS) concepts, Hydrology concepts, etc. that people could potentially benefit from.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h1>
<p>You can read this book sequentially to understand the concepts used in the NADI system. And then go through the references sections for a specific use cases you want to get into the details of.</p>
<p>If you are in a hurry, but this is your first time reading this book,
at least read the <a href="./intro.html">Core Concepts</a>, then refer to the
section you are interested in. <a href="./learn-examples.html">Learn by Example</a></p>
<h2 id="code-blocks"><a class="header" href="#code-blocks">Code Blocks</a></h2>
<p>The code blocks will have example codes for various languages, most common will be <code>string template</code>, <code>task</code>, and <code>rust</code> codes.</p>
<p>String template and task have custom syntax highlights that is
intended to make it easier for the reader to understand different
semantic blocks.</p>
<p>For <code>task</code> scripts/functions, if relevant to the topic, they might
have <code>Results</code> block following immediately showing the results of the
execution.</p>
<p>For example:</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>node[ohio] render("{_NAME:case(title)} River")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  ohio = "Ohio River"
}
</code></pre>
<p>Task and Rust code block might also include lines that are needed to
get the results, but hidden due to being irrelevant to the
discussion. In those cases you can use the eye icon on the top right
side of the code blocks to make them visible. Similarly use the copy
icon to copy the visible code into clipboard.</p>
<h2 id="string-template-syntax-highlight"><a class="header" href="#string-template-syntax-highlight">String Template Syntax Highlight</a></h2>
<p>The syntax highlight here in this book makes it so that any unknown
transformers will be marked for easy detection to mistakes.</p>
<pre><code class="language-stp">This shows var = {var:unknown()}, {_var:case(title)}
</code></pre>
<p>Besides this, the syntax highlight can help you detect the variables
part (within <code>{}</code>), lisp expression (within <code>=()</code>), or commands
(within <code>$()</code>) in the template.</p>
<p>Note: commands are disabled, so they won’t run during template
rendering process. But if you are rendering a template to run as a
command, then they will be executed during that process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-cite"><a class="header" href="#how-to-cite">How to Cite</a></h1>
<p>The sections below show you a bibliography entry in ASCE format, and BibTeX format that you can copy.</p>
<h2 id="journal-papers-todo"><a class="header" href="#journal-papers-todo">Journal Papers: TODO</a></h2>
<p>The papers are currently still being worked on, and will be added here when they are published.</p>
<h2 id="this-book"><a class="header" href="#this-book">This book</a></h2>
<p>You can cite the link to this book as follows Make sure to replace Accessed Data by today’s date.</p>
<p>Atreya, G. 2025. “Network Analysis and Data Integration (NADI).” Accessed May 1, 2025. https://nadi-system.github.io/.</p>
<pre><code>@misc{PrefaceNetworkAnalysis,
  title = {Network {{Analysis}} and {{Data Integration}} ({{NADI}})},
  author = {Atreya, Gaurav},
  year = {2025},
  url = {https://nadi-system.github.io/},
  urldate = {2025-05-02}
}
</code></pre>
<h1 id="works-using-nadi-system"><a class="header" href="#works-using-nadi-system">Works using Nadi System</a></h1>
<p>Atreya, G., G. Mandavya, and P. Ray. 2024. “Which came first? Streamgages or Dams: Diving into the History of Unaltered River Flow Data with a Novel Analytical tool.” H51L-0865.</p>
<pre><code>@inproceedings{atreyaWhichCameFirst2024,
  title = {Which Came First? {{Streamgages}} or {{Dams}}: {{Diving}} into the {{History}} of {{Unaltered River Flow Data}} with a {{Novel Analytical}} Tool},
  shorttitle = {Which Came First?},
  booktitle = {{{AGU Fall Meeting Abstracts}}},
  author = {Atreya, Gaurav and Mandavya, Garima and Ray, Patrick},
  year = {2024},
  month = dec,
  volume = {2024},
  pages = {H51L-0865},
  urldate = {2025-06-03},
  annotation = {ADS Bibcode: 2024AGUFMH51L.0865A}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-analysis-and-data-integration-nadi"><a class="header" href="#network-analysis-and-data-integration-nadi">Network Analysis and Data Integration (NADI)</a></h1>
<p>NADI is group of software packages that facilitate network analysis and do data analysis on data related to network/nodes.</p>
<p>NADI System consists of:</p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td>NADI GIS</td><td>Geographic Information (GIS) Tool for Network Detection</td></tr>
<tr><td>NADI Task System</td><td>Domain Specific Programming Language</td></tr>
<tr><td>NADI Plugins</td><td>Plugins that provide the functions in Task System</td></tr>
<tr><td>NADI library</td><td>Rust and Python library to use in your programs</td></tr>
<tr><td>NADI CLI</td><td>Command Line Interface to run NADI Tasks</td></tr>
<tr><td>NADI IDE</td><td>Integrated Development Environment to write/ run NADI Tasks</td></tr>
</tbody></table>
</div>
<p>The github repositories consisting of source codes:</p>
<div class="table-wrapper"><table><thead><tr><th>Repo</th><th>Tool</th></tr></thead><tbody>
<tr><td><a href="https://github.com/Nadi-System/nadi-gis">nadi-gis</a></td><td>Nadi GIS</td></tr>
<tr><td><a href="https://github.com/Nadi-System/nadi-system">nadi-system</a></td><td>Nadi CLI/ IDE/ Core</td></tr>
<tr><td><a href="https://github.com/Nadi-System/nadi-plugins-rust">nadi-plugins-rust</a></td><td>Sample Plugins</td></tr>
<tr><td><a href="https://github.com/Nadi-System/nadi-book">nadi-book</a></td><td>Source for this Nadi Book</td></tr>
</tbody></table>
</div>
<h2 id="nadi-gis"><a class="header" href="#nadi-gis">NADI GIS</a></h2>
<p>Geographic Information (GIS) Tool for Network Detection. The main purpose of the NADI GIS is to find the network connectivity between a set of points using a stream network (which can be developed from elevation models, or downloaded from national databases).</p>
<p>NADI GIS can be used as a terminal command or QGIS plugin, refer to <a href="installation.html#nadi-gis">installation</a> section for how to install it.</p>
<h2 id="nadi-task-system"><a class="header" href="#nadi-task-system">NADI Task System</a></h2>
<p>Task System is a Domain Specific Programming Language (DSL) that is designed for river network analysis. This is the main core of the network analysis. This is included when you install NADI as a library, CLI or GUI.</p>
<h2 id="nadi-plugins"><a class="header" href="#nadi-plugins">NADI Plugins</a></h2>
<p>The functions available to call in the task system comes from plugins. There are many internal plugins with core functions already available, while users can load their own plugins for other functions.</p>
<p>Refer to the plugins section of the book for more details on how to use plugins, how to write them and what to keep in mind while using them.</p>
<h2 id="nadi-libraries"><a class="header" href="#nadi-libraries">NADI libraries</a></h2>
<p>Rust and Python library to use in your programs. Rust library <code>nadi_core</code> is available to download/use from <code>cargo</code> with the command <code>cargo add nadi_core</code>.</p>
<p>While Python library requires you to clone the repo and build it with <code>maturin</code> (for now).
Future plan for it includes publishing it in pypi.</p>
<h3 id="rust-libraries"><a class="header" href="#rust-libraries">Rust Libraries</a></h3>
<p>If you are not writing your own rust programs or plugins, you can skip this section.</p>
<p>There are three rust libraries:</p>
<div class="table-wrapper"><table><thead><tr><th>Library</th><th>Use</th></tr></thead><tbody>
<tr><td><code>nadi_core</code></td><td>Core library with data types, and plugin structure</td></tr>
<tr><td><code>nadi_plugin</code></td><td>Rust Procedural macro library to write nadi plugins</td></tr>
<tr><td><code>string_template_plus</code></td><td>Library for string templates with variables</td></tr>
</tbody></table>
</div>
<p>Everything is loaded by <code>nadi_core</code> so you don’t need to load them separately.</p>
<h3 id="nadi-python"><a class="header" href="#nadi-python">NADI Python</a></h3>
<p>While using NADI from python library, you only have access to nadi data types (Node, Network, etc), and the plugin functions, which are enough for most cases as python language syntax, variables, loops etc will give you a lot of flexibility on how to do your own analysis. The python module is structured as follows:</p>
<pre><code>nadi [contains Node, Network, etc]
 +-- functions
 | +-- node [contains node functions]
 | +-- network [contains network functions]
 | +-- env [contains env functions]
 +-- plugins
   +-- &lt;plugin&gt; [each plugin will be added here]
   | +-- node [contains node functions]
   | +-- network [contains network functions]
   | +-- env [contains env functions]
   +-- &lt;next-plugin&gt; and so on ...
</code></pre>
<p>The functions are available directly through <code>functions</code> submodule, or through each plugin in <code>plugins</code> submodule. An example python script looks like this:</p>
<pre><code class="language-python">import nadi
import nadi.functions as fn

net = nadi.Network("data/ohio.network")
for node in net.nodes:
    try:
        _ = int(node.name)
        node.is_usgs = True
        print(fn.node.render(node, "Node {_NAME} is USGS Site"))
    except ValueError:
        node.is_usgs = False
</code></pre>
<p>This code shows how to load a network, how to loop through the nodes, and use python logic, or use nadi functions for the node and assign attributes.</p>
<p>More detail on how to use NADI from python will be explained in NADI Python chapter.</p>
<h2 id="nadi-cli"><a class="header" href="#nadi-cli">NADI CLI</a></h2>
<p>Command Line Interface to run NADI Tasks.</p>
<p>This can run nadi task files, syntax highlight them for verifying them, generate markdown documentations for the plugins. The documentations included in this book (<a href="plugins/index.html">Function List</a> and each plugin’s page like <a href="plugins/attrs.html">Attributes Plugin <code>attrs</code></a>) are generated with that. The documentation on each plugin functions comes from their docstrings in the code, please refer to how to write plugins section of the book for details on that.</p>
<p>The available options are shown below.</p>
<pre><code>Usage: nadi [OPTIONS] [TASK_FILE]

Arguments:
  [TASK_FILE]  Tasks file to run; if `--stdin` is also provided this runs before stdin

Options:
  -C, --completion &lt;FUNC_TYPE&gt;   list all functions and exit for completions [possible values: node, network, env]
  -c, --fncode &lt;FUNCTION&gt;        print code for a function
  -f, --fnhelp &lt;FUNCTION&gt;        print help for a function
  -g, --generate-doc &lt;DOC_DIR&gt;   Generate markdown doc for all plugins and functions
  -l, --list-functions           list all functions and exit
  -n, --network &lt;NETWORK_FILE&gt;   network file to load before executing tasks
  -p, --print-tasks              print tasks before running
  -P, --new-plugin &lt;NEW_PLUGIN&gt;  Create the files for a new nadi_plugin
  -N, --nadi-core &lt;NADI_CORE&gt;    Path to the nadi_core library for the new nadi_plugin
  -s, --show                     Show the tasks file, do not do anything
  -S, --stdin                    Use stdin for the tasks; reads the whole stdin before execution
  -r, --repl                     Open the REPL (interactive session) before exiting
  -t, --task &lt;TASK_STR&gt;          Run given string as task before running the file
  -h, --help                     Print help
  -V, --version                  Print version
</code></pre>
<h2 id="nadi-ide"><a class="header" href="#nadi-ide">NADI IDE</a></h2>
<p>NADI Integrated Development Environment (IDE) is a Graphical User Interface (GUI) for the users to write/ run NADI Tasks.</p>
<p>As seen in the image below, IDE consists of multiple components arranged in a tiling manner. You can drag them to move them around and build your own layout. When you start IDE it suggests you some layouts and what to open. You can use the buttons on the top right of each pane to:</p>
<ul>
<li>change pane type</li>
<li>vertically split current pane</li>
<li>horizontally split current pane</li>
<li>fullscreen current page/ restore layout if it’s fullscreen</li>
<li>close current pane</li>
</ul>
<p><img src="./images/ide-screenshot.png" alt="Screenshot of NADI IDE" /></p>
<p>It has the following components:</p>
<h3 id="text-editor"><a class="header" href="#text-editor">Text Editor</a></h3>
<p>Open text files, edit and save them.</p>
<p>It comes with syntax highlighting for most languages. And custom highlight for tasks and network files.</p>
<p>For Tasks file, it can also show you function signatures on top so you can write tasks easily, knowing what arguments the function needs and what the default values are.</p>
<p>While open inside IDE, it can also run the tasks by sending them to the terminal, or search help documentations on functions. Hover over the buttons on the top row to see which button does what, and the keyboard shortcut to use them as well.</p>
<h3 id="terminal"><a class="header" href="#terminal">Terminal</a></h3>
<p>Terminal is there so you can run NADI in a interactive session. Read Eval Print Loop (REPL) of NADI here is meant mostly to be used inside the IDE to evaluate the tasks from editor, but you can open it independently as well.</p>
<h3 id="function-help"><a class="header" href="#function-help">Function Help</a></h3>
<p>This is a GUI with the list of all available plugin functions. You can expand the sidebar on left to search and browse functions. You can filter by type of function (node, network, env) with the buttons. When you click a function you can read its documentation on the right side.</p>
<p>Capabilities of the <code>iced</code> GUI libraries are limited right now, so you cannot select or copy text from the help. Please refer to the documentation online to do that. Or generate the documentation locally using <code>nadi-cli</code> tool.</p>
<h3 id="network-viewer"><a class="header" href="#network-viewer">Network Viewer</a></h3>
<p>This is a pane where network is visualized, this is a very basic visualization to see the connections and is not optimized for drawing. Please avoid using this pane (making it visible) in case of large networks as it takes a lot of computation to draw this each frame.</p>
<h3 id="attribute-browser"><a class="header" href="#attribute-browser">Attribute Browser</a></h3>
<p>When you click on a node on Network Viewer it will open/update showing the attributes of that node. There is no way to edit the attributes from here, which is intensional design as attributes should be assigned from tasks so that they are reproducible. For temporary assignments use the terminal.</p>
<h3 id="svg-viewer"><a class="header" href="#svg-viewer">SVG Viewer</a></h3>
<p>This is a basic utility that can open a SVG file from disk and visualize it. You can click the refresh button to re-read the same file. This is intended for a quick way to check the SVG saved/exported from tasks. This is not a full fledge SVG renderer, so open them in image viewers or browsers to see how it looks.</p>
<h1 id="trivia"><a class="header" href="#trivia">Trivia</a></h1>
<ul>
<li>Nadi means River in Nepali (and probably in many south asian languages).</li>
<li>First prototype of NADI was Not Available Data Integration, as it
was meant to be an algorithm to fill data gaps using network
information, but it was modified to be more generic for many network
related analysis.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Nadi System is a suite of software packages each have different
installation methods. Some of the packages are uploaded to <code>crates.io</code>
(rust) and <code>pypi</code> (python).  For others, you can either get the
compiled binaries from the Releases page of the
github repo [windows]. Or you can get the source code using <code>git</code>, and using
<code>cargo</code> build the packages [all OS].</p>
<h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<p>For <code>nadi-py</code> you can use <code>pip</code>:</p>
<pre><code class="language-bash">pip install nadi-py
</code></pre>
<p>For <code>nadi-cli</code> you can use <code>cargo</code>:</p>
<pre><code class="language-bash">cargo install nadi
</code></pre>
<h1 id="downloading-binaries"><a class="header" href="#downloading-binaries">Downloading Binaries</a></h1>
<p>Goto the repo of each component and refer to the releases section for binaries of different versions.</p>
<ul>
<li><a href="https://github.com/Nadi-System/nadi-system/releases">nadi-system binaries</a></li>
<li><a href="https://github.com/Nadi-System/nadi-gis/releases">nadi-gis binaries</a></li>
<li><a href="https://github.com/Nadi-System/nadi-plugins-rust/releases">plugins binaries</a></li>
</ul>
<p>To setup the nadi-systm to load the plugins you have to place them inside the directory included in the <code>NADI_PLUGIN_DIRS</code> environmental variable. Refer to your Operating System’s documentation on how to set environemental variables.</p>
<p>The binaries should be able to run directly without needing extra steps. If you get a security warnings because the binaries are not signed, you might have to ignore it.</p>
<h1 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h1>
<p>This is currently the preferred way of installing <code>nadi-system</code> (and <code>nadi-gis</code> for Linux and MacOS). Although it includes a bit more steps this makes sure the compiled program is compatible with your OS.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>The prerequisites for building from source are:</p>
<ul>
<li><code>git</code> [Optional]: to clone the repo, you can directly download zip from github</li>
<li><code>cargo</code>: To build the binaries from source.</li>
<li><code>gdal</code> [Optional]: Only for <code>nadi_gis</code> binary and plugin.</li>
</ul>
<p>To install <code>git</code> refer to the instructions for your operating system from the <a href="https://git-scm.com/downloads">official page</a>.</p>
<p>For <code>cargo</code> follow the instructions to install rust toolsets for your operating system from the <a href="https://www.rust-lang.org/tools/install">official page</a></p>
<p>Installing <code>gdal</code> can be little complicated for windows. For Linux, use your package manager to install <code>gdal</code> and/or <code>gdal-dev</code> package. Mac users can also install <code>gdal</code> using <a href="https://brew.sh/"><code>homebrew</code></a>. For windows, follow the instructions from <a href="https://gdal.org/en/stable/download.html#windows">official website</a>, after installation you might have to make some changes to environmental variables to let <code>cargo</code> know where your <code>gdal</code> binaries/header files are for the compilation to be successful. More details will be provided in the NADI GIS section.</p>
<p>If you use Linux or Mac (with homebrew), then the installation of prerequisites should be easy. But if you do not have the confidence to setup <code>gdal</code> for compiling <code>nadi_gis</code> use the binaries provided for them from the previous steps.</p>
<h2 id="nadi-system"><a class="header" href="#nadi-system">NADI System</a></h2>
<p>It will build the binaries for <code>nadi</code>, <code>nadi-ide</code>, <code>nadi-help</code>, <code>nadi-editor</code>, etc. <code>nadi</code> is the command line interface to run nadi tasks, parse/validate syntax etc. While <code>nadi-ide</code> is the program to graphically develop nadi tasks and run them.</p>
<p>Assuming you have <code>git</code> and <code>cargo</code>,</p>
<pre><code class="language-bash">git clone https://github.com/Nadi-System/nadi-system
cd nadi-system
cargo build --release
</code></pre>
<p>To run one of the binary from nadi system, use the command <code>cargo run</code> with binary name.</p>
<p>For example, the following will run the <code>nadi-ide</code>:</p>
<pre><code class="language-bash">cargo run --release --bin nadi-ide
</code></pre>
<p>The compiled binaries will be saved in the <code>target/release</code> directory, you can copy them and distribute it. The binaries do not need any other files to run.</p>
<p>The plugins files if present in the system are automatically loaded from <code>NADI_PLUGIN_DIRS</code> environmental variable. Look into installing the plugin section below.</p>
<p>Note: all programs will compile and run in Windows, Linux, and MacOS, while only <code>nadi-cli</code> and <code>mdbook-nadi</code> will run in Android (tmux). <code>nadi-ide</code> and family need the GUI libraries that are not available for android (tmux) yet.</p>
<h2 id="nadi-gis-1"><a class="header" href="#nadi-gis-1">NADI GIS</a></h2>
<p>NADI GIS uses <code>gdal</code> to read/write GIS files, so it needs to be installed. Please refer to <a href="https://gdal.org/en/stable/download.html">gdal installation documentation</a> for that.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>First download compiled gdal from here:</p>
<ul>
<li>https://www.gisinternals.com/sdk.php
Then download clang from here:</li>
<li>https://github.com/llvm/llvm-project/releases</li>
</ul>
<p>Extract it into a folder, and then set environmental variables to point to that:</p>
<ul>
<li><code>GDAL_VERSION</code>: Version of gdal e.g. ‘3.10.0’</li>
<li><code>LIBCLANG_PATH</code>: Path to the <code>lib</code> directory of <code>clang</code></li>
<li><code>GDAL_HOME</code>: Path to the <code>gdal</code> that has the subdirectories like <code>bin</code>, <code>lib</code>, etc.</li>
</ul>
<p>You can also follow the errors from the rust compilers as you compile to set the correct variables.</p>
<p>Finally you can get the source code and compile <code>nadi-gis</code> with the following command:</p>
<pre><code class="language-bash">git clone https://github.com/Nadi-System/nadi-gis
cd nadi-gis
cargo build --release
</code></pre>
<p>This will generate the <code>nadi-gis</code> binary and <code>gis.dll</code> plugin in the <code>target/release</code> folder, they need to be run along side the <code>gdal</code> shared libraries (<code>.dll</code>s). Place the binaries in the same folder as the <code>dll</code>s from <code>gdal</code> and run it. To use the <code>gis.dll</code> plugin from <code>nadi</code>, <code>nadi-ide</code>, etc. same thing applies there, those binaries should be run with the <code>gdal</code>’s <code>dll</code>s to be able to load the <code>gis</code> plugin.</p>
<h3 id="linux-and-mac"><a class="header" href="#linux-and-mac">Linux and Mac</a></h3>
<p>Assuming you have <code>git</code>, <code>cargo</code>, and <code>gdal</code> installed in your system you can build it like this:</p>
<pre><code class="language-bash">git clone https://github.com/Nadi-System/nadi-gis
cd nadi-gis
cargo build --release --features bindgen
</code></pre>
<p>The <code>bindgen</code> feature will link the <code>nadi-gis</code> binary with the <code>gdal</code> from your system. So that you do not have to distribute <code>gdal</code> with the binary for your OS.</p>
<p>If you do not have <code>gdal</code> installed in your system, then you can still build the nadi-gis without the <code>bindgen</code> feature. This will still require <code>gdal</code> to be available and distributed with the binary.</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="qgis-plugin"><a class="header" href="#qgis-plugin">QGIS Plugin</a></h3>
<p>The <code>nadi-gis</code> repo also contains the QGIS plugin that can be installed to run it through QGIS. The plugin will use the <code>nadi-gis</code> binary in your <code>PATH</code> if available. And it also contains the nadi plugin that can be loaded into the nadi system to import/export GIS files into/from the system.</p>
<p>You can download the zip file for plugin from releases page, and use the “Install from Zip” option on QGIS plugins tab. Or copy the <code>nadi</code> directory inside <code>qgis</code> to your python plugin directory for qgis.</p>
<p>Refer to the <a href="https://docs.qgis.org/3.40/en/docs/training_manual/qgis_plugins/fetching_plugins.html">QGIS plugins page</a> for more instructions. In future we are planning on publishing the plugin so that you can simply add it from QGIS without downloading from here.</p>
<h3 id="nadi-gis-plugin"><a class="header" href="#nadi-gis-plugin">Nadi GIS Plugin</a></h3>
<p>The nadi plugin on this repo provides the functions to import attributes, geometries from GIS files, and export them into GIS files.</p>
<h2 id="nadi-plugins-1"><a class="header" href="#nadi-plugins-1">Nadi Plugins</a></h2>
<p>Out of the two types of plugins, the executable plugins are just simple commands, they do not need to be installed along side nadi, just make sure the executables that you are using from <code>nadi</code> can be found in path. A simple way to verify that is to try to run that from terminal and see if it works.</p>
<p>The compiled plugins can be loaded by setting the <code>NADI_PLUGIN_DIRS</code> environmental variable. The environment variable should be the path to the folder containing the nadi plugins (in <code>.dll</code>, <code>.so</code>, or <code>.dylib</code> formats for windows, linux and mac). You can write your own plugins based on our examples and compile them.</p>
<p>Officially available plugins are in the <code>nadi-plugins-rust</code> directory.</p>
<p>Assuming you have <code>git</code> and <code>cargo</code>,</p>
<pre><code class="language-bash">git clone https://github.com/Nadi-System/nadi-plugins-rust
cd nadi-gis
cargo build --release
</code></pre>
<p>The plugins will be inside the <code>target/release</code> directory. Copy them to the <code>NADI_PLUGIN_DIRS</code> directory for nadi to load them.</p>
<p>You can take any one of the plugins as an example to build your own, or following the plugin development instructions from the plugins chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<div class="warning">
Plugins allow users to extend the use case of the Nadi System by adding more functions or scripts. User are expected to only use plugins from trusted sources, or develop it in-house. Although the compiled plugin functions have their code exposed in their documentation for the transparency purposes even if the source code is not available, always make sure the plugin you run are not malicious.
</div>
<p>There are two types of nadi plugins.
Compiled plugins (shared libraries) are loaded dynamically from shared libraries, while executable plugins are called as shell commands. Refer to <a href="./intro/plugins.html">Plugins</a> section of core concepts for more details.</p>
<h2 id="compiled-plugins"><a class="header" href="#compiled-plugins">Compiled Plugins</a></h2>
<p>Compiled plugins are shared libraries (<code>.so</code> in linux, <code>.dll</code> in windows, and <code>.dylib</code> on macOS). They can be generated by compiling the nadi plugin in rust, or you can download the correct plugin for your OS and <code>nadi_core</code> version from the plugin repositories. It is recommended to only use plugins from trusted source.</p>
<p>To setup the nadi-systm to load the compiled plugins you have to place them inside the directory included in the <code>NADI_PLUGIN_DIRS</code> environmental variable. Refer to your Operating System’s documentation on how to set environemental variables.</p>
<p>The compiled plugins are loaded when NADI is starting up, there is no way to <code>hot load</code> or <code>reload</code> the plugins, so you need to reopen the nadi program itself (CLI, IDE, etc) if you want to load new/updated plugin functions.</p>
<p>Once the plugins are loaded, the functions are directly available from the nadi task system, they’ll act similar to the internal plugin functions.</p>
<h2 id="executable-plugins"><a class="header" href="#executable-plugins">Executable Plugins</a></h2>
<p>Executable plugins are terminal commands, you set it up as you’d set any other terminal programs, by making sure the program is in <code>PATH</code> and can be executed from terminal. Linux and Mac do them mostly by default, while in Windows you might have to check the box saying something along the lines of “include this in path” during installation, or manually edit the <code>PATH</code> in “Environment Variables”.</p>
<p>For example, if you want to call python scripts, make sure you can run <code>python --version</code> in terminal and get a response.</p>
<p>You can also check it using the <code>command</code> function:</p>
<pre><code class="language-task">network command("python --version", echo=true)
network command("Rscript --version", echo=true)
network command("julia --version", echo=true)
</code></pre>
<p>Results:</p>
<pre><code class="language-output">$ python --version
Python 3.13.5

$ Rscript --version
Rscript (R) version 4.5.1 (2025-06-13)

$ julia --version
julia version 1.11.5
</code></pre>
<p>Here we can see, the commands that ran successfully and returned a version are valid.</p>
<p>To write scripts and run them from nadi refer to <a href="plugin-dev/exe-plugins.html">Executable Plugins</a> section on Plugin Developer Guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nadi-gis-2"><a class="header" href="#nadi-gis-2">Nadi GIS</a></h1>
<p>Nadi GIS is available as a CLI tool and QGIS plugin, the CLI tool has the following functions:</p>
<pre><code>Usage: nadi-gis [OPTIONS] &lt;COMMAND&gt;

Commands:
  nid      Download the National Inventory of Dams dataset
  usgs     Download data from USGS NHD+
  layers   Show list of layers in a GIS file
  check    Check the stream network to see outlet, branches, etc
  order    Order the streams, adds order attribute to each segment
  network  Find the network information from streams file between points
  help     Print this message or the help of the given subcommand(s)

Options:
  -q, --quiet  Don't print the stderr outputs
  -h, --help   Print help
</code></pre>
<p>The important functions are:</p>
<ul>
<li>Download NID and USGS NHD+ data,</li>
<li>Check stream network for validity of DAG (Directed Acyclic Graph) required for NADI,</li>
<li>Stream ordering for visual purposes,</li>
<li>Network detection between points of interest using the stream network</li>
</ul>
<p>You can use the help command for each one of the subcommand for more help.
For example, <code>usgs</code> subcommand’s help using <code>nadi-gis help usgs</code> gets us:</p>
<pre><code>Download data from USGS NHD+

Usage: nadi-gis usgs [OPTIONS] --site-no &lt;SITE_NO&gt;

Options:
  -s, --site-no &lt;SITE_NO&gt;
          USGS Site number (separate by ',' for multiple)

  -d, --data &lt;DATA&gt;
          Type of data (u/d/t/b/n)
          
          [upstream (u), downstream (d), tributaries (t), basin (b), nwis-site (n)]
          
          [default: b]

  -u, --url
          Display the url and exit (no download)

  -v, --verbose
          Display the progress

  -o, --output-dir &lt;OUTPUT_DIR&gt;
          [default: .]

  -h, --help
          Print help (see a summary with '-h')
</code></pre>
<h1 id="nadi-qgis"><a class="header" href="#nadi-qgis">NADI QGIS</a></h1>
<p>The QGIS plugin for nadi has a subset of the CLI functionality. It can be accessed from the Processing Toolbox.</p>
<p><img src="gis/../images/qgis-processing.png" alt="QGIS Processing Toolbox" /></p>
<p>You can run the tools from there and use the layers in QGIS as inputs. The QGIS plugin will first try to find <code>nadi-gis</code> binary on your <code>PATH</code> and use it, if not it’ll try to use the binary provided with the plugins. It is preferred to have <code>nadi-gis</code> available in <code>PATH</code> and running without errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>The examples here will be given using QGIS plugin, and using the CLI tool both. CLI tool is great for quickly running things, and doing things in batch, while QGIS plugin will be better on visualization and manual fixes using other GIS tools.</p>
<h2 id="using-qgis-plugin"><a class="header" href="#using-qgis-plugin">Using QGIS Plugin</a></h2>
<p>First <strong>downloading the data</strong> is done through the <code>Download USGS Data</code> tool. As shown in the screenshot below, input the USGS site ID and the data type you want to download.</p>
<p><img src="gis/../images/qgis-download.png" alt="QGIS Download" /></p>
<p>You will need, <code>tributaries</code> for the upstream tributaries for network, and <code>nwis-site</code> will download the USGS NWIS sites upstream of the location. We will use those two for the example. If you have national data from other sources, you can use the basin polygon to crop them.</p>
<p><strong>Stream Order</strong> tool is mostly for visual purposes. The figure below shows the results from stream order on right compared to the raw download on left.</p>
<p><img src="gis/../images/qgis-order.png" alt="Stream Order Result" /></p>
<p>After you have streams (tributaries), you can use the <strong>Check Streams</strong> tool to see if there are any errors. It will give all the nodes and their categories, you can filter them to see if it has branches, or if it has more than one outlet. The figure below shows the branches with red dot. If we zoom in we can see how the bifurcation on the stream is detected, and how stream order calculation is confused there.</p>
<p><img src="gis/../images/qgis-branch.png" alt="Check Streams Result" /></p>
<p><strong>Find Connections</strong> tool will find the connection between the points using the stream network. The results below shows the tool being run on the NWIS points.</p>
<p><img src="gis/../images/qgis-network.png" alt="Find Connections Result" /></p>
<p>If we select <strong>simplify</strong> option, it’ll only save the start and end point of the connection instead of the whole stream.</p>
<p><img src="gis/../images/qgis-network2.png" alt="Find Connections Result Alt" /></p>
<p>Of course you can run <strong>Stream Order</strong> on the results to get a more aesthetically pleasing result.</p>
<p><img src="gis/../images/qgis-network3.png" alt="Find Connections Result with Order" /></p>
<h2 id="using-cli"><a class="header" href="#using-cli">Using CLI</a></h2>
<p>An example of running <code>nadi-gis</code> using CLI can be done in the following steps:</p>
<h3 id="download-data"><a class="header" href="#download-data">Download data</a></h3>
<p>We’ll download the streamlines and the NWIS Sites from USGS for station 03217200 (Ohio River at Portsmouth, OH).</p>
<pre><code class="language-bash">nadi-gis usgs -s 03217200 -d n -d t -o output/
</code></pre>
<p>This will download two files:</p>
<pre><code>output/03217200_nwis-site.json  output/03217200_tributaries.json
</code></pre>
<p>Now we can use <code>check</code> command to see if there are any problems with the streams.</p>
<pre><code class="language-bash">nadi-gis check output/03217200_tributaries.json
</code></pre>
<p>That gives us the following output:</p>
<pre><code>Invalid Streams File: Branches (826)
* Outlet: 1
* Branch: 826
* Confluence: 30321
* Origin: 29591
</code></pre>
<p>We can generate a GIS file to locate the branches and see if those are significant. Refer to the <code>help</code> for <code>check</code> or use the QGIS plugin.</p>
<p>And to find the connections, we use <code>network</code> subcommand like this:</p>
<pre><code class="language-bash">nadi-gis network -i output/03217200_nwis-site.json output/03217200_tributaries.json
</code></pre>
<p>Output:</p>
<pre><code>Outlet: 3221 (-82.996916801, 38.727624498) -&gt; None
3847 -&gt; 3199
2656 -&gt; 2644
399 -&gt; 1212
2965 -&gt; 3942
2817 -&gt; 6236
5708 -&gt; 4733
2631 -&gt; 5741
201 -&gt; 2101
2066 -&gt; 2317
3770 -&gt; 1045
... and so on
</code></pre>
<p>Since this is not as useful, we can use the flags in the <code>network</code> subcommand to use a different id, and save the results to a network file.</p>
<p>First we can use <code>layers</code> subcommand to see the available fields in the file:</p>
<pre><code class="language-bash">nadi-gis layers output/03217200_nwis-site.json -a
</code></pre>
<p>which gives us:</p>
<pre><code>03217200_nwis-site
  - Fields:
    + "type" (String)
    + "source" (String)
    + "sourceName" (String)
    + "identifier" (String)
    + "name" (String)
    + "uri" (String)
    + "comid" (String)
    + "reachcode" (String)
    + "measure" (String)
    + "navigation" (String)
</code></pre>
<p>Using <code>comid</code> as the id for points, and saving the results:</p>
<pre><code class="language-bash">nadi-gis network -i output/03217200_nwis-site.json output/03217200_tributaries.json -p comid -o output/03217200.network
</code></pre>
<p>The <code>output/03217200.network</code> file will have the connections like:</p>
<pre><code>15410797 -&gt; 15411587
6889212 -&gt; 6890126
8980342 -&gt; 10220188
19440469 -&gt; 19442989
19390000 -&gt; 19389366
6929652 -&gt; 6929644
... and so on
</code></pre>
<p>Make sure you use a field with unique name, and valid identifier in NADI System.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>This section contains a brief explanation of core concepts.</p>
<p>The main concepts that you need to know are:</p>
<ul>
<li>
<p><strong>Attributes</strong> are values, it can be float, integer, boolean, strings, or list of attributes, or a map of attributes (key=value),</p>
</li>
<li>
<p><strong>Nodes</strong> are points in the network, they can have attributes, input nodes and an output node,</p>
</li>
<li>
<p><strong>Network</strong> is a collection of nodes, network can also have attributes, Network used in the Nadi system can have only one outlet, so a ‘ROOT’ node is added if there are multiple outlet. And loading a network that is not a directed tree is undefined behaviour.</p>
</li>
<li>
<p><strong>Expression</strong> is something that can be evaluated or executed, it consists of literal values (attributes), variables (node, network, env variables that could hold attributes), function calls, or a mathmatical or logical operation.</p>
</li>
<li>
<p><strong>Functions</strong> in nadi are of 3 types, env functions are normal functions that take values and run, network functions take values and run on the network, while node functions run at each node (they also provide a way to subset which nodes to run it on).</p>
</li>
<li>
<p><strong>Task</strong> is an execution body of the task system. It can be of env, network or node type. It can be conditional (If-Else) or loop (While) consisting of more tasks inside it. Task can assign values to the env/network/node attributes, or call mutable functions on the top level.</p>
</li>
<li>
<p><strong>String Template</strong>: Some functions take string inputs that are interpreted dynamically to represent different strings based on variables.</p>
</li>
<li>
<p><strong>Plugins</strong> provide the functions used by the nadi task system. There are internal plugins and external plugins. Internal plugins comes with the installation, while external plugins are loaded from dynamic libraries.</p>
</li>
</ul>
<h2 id="keywords"><a class="header" href="#keywords">Keywords</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Description</th></tr></thead><tbody>
<tr><td>node</td><td>the node task type, function or variable</td></tr>
<tr><td>network/net</td><td>the network task type, function or variable</td></tr>
<tr><td>env</td><td>the environment task type, function or variable</td></tr>
<tr><td>exit</td><td>exit the program</td></tr>
<tr><td>end</td><td>end the execution of tasks without exiting</td></tr>
<tr><td>help</td><td>display help for functions</td></tr>
<tr><td>inputs</td><td>get node variables or function output for input nodes of a node</td></tr>
<tr><td>output</td><td>get node variable or function output for output node of a node</td></tr>
<tr><td>nodes</td><td>get node variable or function output for all nodes in the network</td></tr>
<tr><td>if</td><td>if statement for conditional task/expression</td></tr>
<tr><td>else</td><td>else statement for conditional task/expression</td></tr>
<tr><td>while</td><td>while statement for loop task</td></tr>
<tr><td>in</td><td>binary operator to check if something is in another (list/string)</td></tr>
<tr><td>match</td><td>binary operator to check patterns on string (regex)</td></tr>
</tbody></table>
</div>
<p>And here are some keywords reserved for future:</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Description</th></tr></thead><tbody>
<tr><td>function/func</td><td>user defined functions</td></tr>
<tr><td>map</td><td>map values in an array/attrmap to a function</td></tr>
<tr><td>attrs</td><td>attributes of the env/node/network</td></tr>
<tr><td>loop</td><td>loop task</td></tr>
<tr><td>for</td><td>for loop task for looping through array/attrmap</td></tr>
</tbody></table>
</div>
<p>Continue with the chapters for details on each concept. Or skip ahead to <a href="system//learn-examples.html">Learn by Examples</a> if you want to jump into the examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task"><a class="header" href="#task">Task</a></h1>
<p>Task is an execution body in the task system. There are different types of tasks, specially environment, network and node type tasks, and there can be conditional tasks that only execute based on a condition or loops.</p>
<p>Some examples of different tasks are given below to show a general overview, but the concepts inside the tasks system will be introduced as we progress through the chapters,</p>
<p>Environment tasks that can evaluate expressions, assign variables, or call functions:</p>
<pre><code class="language-task">env 1 + 2 * 8
env render("my name is {_name}", name="John")
env.x = 12 &gt; 2;
env.x
</code></pre>
<p>Results:</p>
<pre><code class="language-output">17
"my name is John"
true
</code></pre>
<p>network task loading a network, and node task getting node attributes:</p>
<pre><code class="language-task">network load_str("a-&gt;b\nb-&gt;c")
node.NAME
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  c = "c",
  b = "b",
  a = "a"
}
</code></pre>
<p>Conditional and Loop task</p>
<pre><code class="language-task">if ( !val? | (val &gt; 5) ) {
	# if val is not defined or greater than 5, set it to 0
    env.val = 0
}
while (val &lt; 5) {
	env.val = env.val + 1
}
</code></pre>
<p>Results:</p>
<pre><code class="language-output">0 -&gt; 1
1 -&gt; 2
2 -&gt; 3
3 -&gt; 4
4 -&gt; 5
</code></pre>
<p>Tasks system acts like a scripting language for nadi system. A
Task consists of getting/evaluating/setting attributes in environment, network or nodes. The value that can be evaluated are expressions that consists of literal values, variables, or function calls that can either be a environment, node or a network function. Functions are unique based on their names, and can
have default values if users do not pass all arguments.</p>
<p>The code examples throughout this book, that are being used to
generate network diagrams, tables, etc are run using the task system.</p>
<p>Here is an example contents of a more complex task file, do not concern with what each task does, we will go through them in other chapters.</p>
<pre><code class="language-task"># sample .tasks file which is like a script with functions
node&lt;inputsfirst&gt; print_attrs("uniqueID")
node show_node()
network save_graphviz("/tmp/test.gv")
node&lt;inputsfirst&gt;.cum_val = node.val + sum(inputs.cum_val);

node[WV04113,WV04112,WV04112] print_attr_toml("testattr2")
node render("{NAME} {uniqueID} {_Dam_Height_(Ft)?}")
node list_attr("; ")
# some functions can take variable number of inputs
network calc_attr_errors(
    "Dam_Height_(Ft)",
    "Hydraulic_Height_(Ft)",
    "rmse", "nse", "abserr"
)
node sum_safe("Latitude")
node&lt;inputsfirst&gt; render("Hi {SUM_ATTR}")
# multiple line for function arguments
network save_table(
	"test.table",
	"/tmp/test.tex",
	true,
	radius=0.2,
	start = 2012-19-20,
	end = 2012-19-23 12:04
	)
node.testattr = 2
node set_attrs_render(testattr2 = "{testattr:calc(+2)}")
node[WV04112] render("{testattr} {testattr2}")

# here we use a complicated template that can do basic logic handling
node set_attrs_render(
    testattr2 = "=(if (and (st+has 'Latitude) (&gt; (st+num 'Latitude) 39)) 'true 'false)"
)
# same thing can be done if you need more flexibility in variable names
node load_toml_string(
    "testattr2 = =(if (and (st+has 'Latitude) (&gt; (st+num 'Latitude) 39)) 'true 'false)"
)
# selecting a list of nodes to run a function
node[
	# comment here?
    WV04113,
    WV04112
] print_attr_toml("testattr2")
# selecting a path
node[WV04112 -&gt; WV04113] render("=(&gt; 2 3)")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>Attributes are <a href="https://toml.io/en/">TOML</a> like values. They can be one of the following types:</p>
<div class="table-wrapper"><table><thead><tr><th>Type Name</th><th>Rust Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Bool</td><td><code>bool</code></td><td>Boolean values (<code>true</code> or <code>false</code>)</td></tr>
<tr><td>String</td><td><code>RString</code></td><td>Quoted String Values</td></tr>
<tr><td>Integer</td><td><code>i64</code></td><td>Integer values (numbers)</td></tr>
<tr><td>Float</td><td><code>f64</code></td><td>Float values (numbers with decimals)</td></tr>
<tr><td>Date</td><td><code>Date</code></td><td>Date (<code>yyyy-mm-dd</code> formatted)</td></tr>
<tr><td>Time</td><td><code>Time</code></td><td>Time (<code>HH:MM</code>, <code>HH:MM:SS</code> formatted)</td></tr>
<tr><td>DateTime</td><td><code>DateTime</code></td><td>Date and Time separed by <code> </code> or <code>T</code></td></tr>
<tr><td>Array</td><td><code>RVec&lt;Attribute&gt;</code></td><td>List of any attribute values</td></tr>
<tr><td>Table/AttrMap</td><td><code>AttrMap</code></td><td>Key Value pairs of any attribute values</td></tr>
</tbody></table>
</div>
<p>You can write attributes directly into the task system to assign them, use them in functions. You can also load attributes from a file into the env/node/network.</p>
<p>If you want to assign a attribute inside the task system, you can do it like this:</p>
<pre><code class="language-task">env.river = "Ohio River"
env.river
</code></pre>
<p>Results:</p>
<pre><code class="language-output">"Ohio River"
</code></pre>
<p>Example Attribute File that can be loaded:</p>
<pre><code class="language-toml">river = "Ohio River"
outlet = "Smithland Lock and Dam"
outlet_is_gage = true
outlet_site_no = ""
streamflow_start = 1930-06-07
mean_streamflow = 123456.0
obs_7q10 = 19405.3
nat_7q10 = 12335.9
num_dams_gages = 2348
</code></pre>
<p>Here loading the files we can see only ohio has the attributes loaded</p>
<pre><code class="language-task"><span class="boring"> network load_file("./data/mississippi.net")
</span>node[ohio] load_attrs("./data/attrs/{_NAME}.toml")
node.outlet
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  lower-mississippi = &lt;None&gt;,
  upper-mississippi = &lt;None&gt;,
  missouri = &lt;None&gt;,
  arkansas = &lt;None&gt;,
  red = &lt;None&gt;,
  ohio = "Smithland Lock and Dam",
  tenessee = &lt;None&gt;
}
</code></pre>
<p>With plugins, you can load attributes from different file types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node"><a class="header" href="#node">Node</a></h1>
<p>A Node is a point in network. A Node can have multiple input nodes and
only one output node. And a Node can also have multiple attributes
identifiable with their unique name, along with timeseries values also
identifiable with their names.</p>
<p>If you understand graph theory, then node in nadi network is the same
as a node in a graph.</p>
<p>Nodes in Nadi are identified by their name, that is loaded from the network file. Node names are string values, even if they are integer or float, they are read and internally stored as strings. If the node name contains characters outside of alphanumeric and underscore (<code>_</code>), it has to be quoted.</p>
<p>i.e. valid names like <code>123</code> or <code>node_1</code> can appear unquoted or quoted, but names like <code>node-123</code> needs to be quoted: <code>"node-123"</code>.</p>
<pre><code class="language-task">network load_str("
123 -&gt; node_1
node_1 -&gt; \"node-123\"
")
node.NAME
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  node-123 = "node-123",
  node_1 = "node_1",
  123 = "123"
}
</code></pre>
<div class="warning">
If the node name `node-123` appearing on the output is unquoted, it's a bug that will be fixed in the next version. It is harmless as long as you don't try to copy the output as a valid attribute value to load back into the system.
</div>
<p>If you do not quote the name, you’ll get an error:</p>
<pre><code class="language-task">network load_str("123 -&gt; node-1")
node.NAME
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">Error in function load_str: Error: Parse Error at Line 1 Column 8
  123 -&gt; node-1
         ^ Incomplete Path; expected node here
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">Network</a></h1>
<p>A Network is a collection of nodes. The network can also have
attributes associated with it. The connection information is stored
within the nodes itself. But Network will have nodes ordered based on
their connection information. So that when you loop from node from
first to last, you will always find output node before its input
nodes.</p>
<p>A condition a nadi network is that it can only be a directed graph
with tree structure.</p>
<p>Example Network file:</p>
<pre><code class="language-net"># network consists of edges where input node goes to output node
# each line is of the format: input -&gt; output
tenessee -&gt; ohio
# if your node name has characters outside of a-zA-Z_, you need to
# quote them as strings
ohio -&gt; "lower-mississippi"
"upper-mississippi" -&gt; "lower-mississippi"
missouri -&gt; "lower-mississippi"
arkansas -&gt; "lower-mississippi"
red -&gt; "lower-mississippi"
</code></pre>
<p>The given network can be loaded and visualized using <code>svg_save</code> function.</p>
<pre><code class="language-task">network load_file("./data/mississippi.net")
<span class="boring">network command("mkdir -p output")
</span>network svg_save(
   "./output/network-mississippi.svg",
	label="[{INDEX}] {_NAME:repl(-, ):case(title)}",
	bgcolor="gray"
)
</code></pre>
<p>Results:</p>
<center>  
<p><img src="intro/../output/network-mississippi.svg" alt="" /></p>
</center>  
<p>You can assign different graphical properties through node properties.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>node[red].visual.nodecolor = "red";
node[ohio].visual.linecolor = "blue";
node[ohio].visual.linewidth = 3;
node["upper-mississippi", red].visual.nodesize = 8;
node[red].visual.nodeshape = "triangle";
node["upper-mississippi"].visual.nodeshape = "ellipse:0.5";
network svg_save(
   "./output/network-mississippi-colors.svg",
   label="[{INDEX}] {_NAME:repl(-, ):case(title)}",
	bgcolor="gray"
)
</code></pre>
<p>Results:</p>
<center>  
<p><img src="intro/../output/network-mississippi-colors.svg" alt="" /></p>
</center>  
<div style="break-before: page; page-break-before: always;"></div><h1 id="expression"><a class="header" href="#expression">Expression</a></h1>
<p>Expressions are airthmetic or logical operations. They can appear inside the conditional statements, or as input to a task, or nested in other expression or function calls.</p>
<p>Expressions are defined into the following categories:</p>
<h2 id="literal-values"><a class="header" href="#literal-values">Literal Values</a></h2>
<pre><code class="language-task">env [1, true, "no maybe"]
</code></pre>
<p>Results:</p>
<pre><code class="language-output">[1, true, "no maybe"]
</code></pre>
<h2 id="variable"><a class="header" href="#variable">Variable</a></h2>
<pre><code class="language-task">env.value = [1, true, "no maybe"];
env.value
</code></pre>
<p>Results:</p>
<pre><code class="language-output">[1, true, "no maybe"]
</code></pre>
<p>Variables also have a “check” mode, where it returns true if variable exists, false if it does not.</p>
<pre><code class="language-task">env.value = [1, true, "no maybe"];
env value?
env other_var?
</code></pre>
<p>Results:</p>
<pre><code class="language-output">true
false
</code></pre>
<p>You can also use use varible from node, or network in other context. For example:</p>
<pre><code class="language-task">env.value = [1, true, "no maybe"];
network echo(json(env.value))
</code></pre>
<p>Results:</p>
<pre><code class="language-output">[1, true, "no maybe"]
</code></pre>
<p>Special variable types like <code>nodes</code>, <code>inputs</code>, <code>output</code> are available besides <code>env</code>, <code>network</code> and <code>node</code> based on what type of task the expression is on.</p>
<p>You will learn more about this on <a href="intro//intro/cross-context.html">Cross Context Functions and Variables</a> chapter.</p>
<h2 id="unary-operator"><a class="header" href="#unary-operator">Unary Operator</a></h2>
<pre><code class="language-task">env !true
env - 12.0
</code></pre>
<p>Results:</p>
<pre><code class="language-output">false
-12
</code></pre>
<h2 id="binary-operator"><a class="header" href="#binary-operator">Binary Operator</a></h2>
<pre><code class="language-task">env (12 &gt; 34) &amp; true
env "x" in "xyz"
env 12 in [123, true]
env "my name is" match "^my.*"
</code></pre>
<p>Results:</p>
<pre><code class="language-output">false
true
false
true
</code></pre>
<h2 id="if-else"><a class="header" href="#if-else">If Else</a></h2>
<pre><code class="language-task">env if(!true) {"if true"} else {"if false"}
</code></pre>
<p>Results:</p>
<pre><code class="language-output">"if false"
</code></pre>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<pre><code class="language-task">env.value = [1, true, "no maybe"];
env get(value, 2)
</code></pre>
<p>Results:</p>
<pre><code class="language-output">"no maybe"
</code></pre>
<p>Out of all expressions, only the function is not garanteed to return a value. If you are using a function expression and expect a value and it does not return it, it’ll be a runtime error.</p>
<pre><code class="language-task">env echo("Hello world!") + 12
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">Hello world!

Function echo did not return a value
</code></pre>
<p>Special function types like <code>nodes</code>, <code>inputs</code>, <code>output</code> are available besides <code>env</code>, <code>network</code> and <code>node</code> based on what type of task the expression is on.</p>
<p>You will learn more about this on <a href="intro//intro/cross-context.html">Cross Context Functions and Variables</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-template"><a class="header" href="#string-template">String Template</a></h1>
<p>String templates are strings with dynamic components that can be
rendered for each node based on the node attributes.</p>
<p>A simple template can be like below:</p>
<pre><code class="language-stp">Hi, my name is {name}, my address is {address?"N/A"}.
I wrote this document on {%A}, exact date: {%Y-%m-%d}.
</code></pre>
<p>Results (with:  name=John; address=123 Road, USA):</p>
<pre><code class="language-output">Hi, my name is John, my address is 123 Road, USA.
I wrote this document on Wednesday, exact date: 2025-07-02.
</code></pre>
<p>With more complicated templates, we would be able to generate
documents with text and images based on the node attributes as well.</p>
<p>For example the following template can be used to generate a table.</p>
<pre><code class="language-markdown">| Name             | Index   |
|------------------|---------|
&lt;!-- ---8&lt;--- --&gt;
| {_NAME:case(up)} | {INDEX} |
&lt;!-- ---8&lt;--- --&gt;
</code></pre>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net");
</span>network echo(render_template("./data/example.template"))
</code></pre>
<p>Results:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Index</th></tr></thead><tbody>
<tr><td>LOWER-MISSISSIPPI</td><td>0</td></tr>
<tr><td>UPPER-MISSISSIPPI</td><td>1</td></tr>
<tr><td>MISSOURI</td><td>2</td></tr>
<tr><td>ARKANSAS</td><td>3</td></tr>
<tr><td>RED</td><td>4</td></tr>
<tr><td>OHIO</td><td>5</td></tr>
<tr><td>TENESSEE</td><td>6</td></tr>
</tbody></table>
</div>
<p>Of course, there are better ways to generate table than this, but this
shows how flexible the template system is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-function"><a class="header" href="#node-function">Node Function</a></h1>
<p>Node function runs on each node. It takes arguments and keyword arguments.</p>
<p>For example following node function takes multiple attribute names and prints them. The signature of the node function is <code>print_attrs(*args)</code>.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>node print_attrs("INDEX", name=false)
</code></pre>
<p>Results:</p>
<pre><code class="language-output">INDEX = 0
INDEX = 1
INDEX = 2
INDEX = 3
INDEX = 4
INDEX = 5
INDEX = 6
</code></pre>
<p>Only the <code>NAME</code> is printed as they do not have any other attributes.</p>
<h2 id="selective-execution"><a class="header" href="#selective-execution">Selective Execution</a></h2>
<p>You can selectively run only a few nodes, or change the order the
nodes are executed.</p>
<p>Given this network:</p>
<center>
<p><img src="intro/../data/mississippi.svg" alt="Network Diagram" /></p>
</center>
<h3 id="inverse-order"><a class="header" href="#inverse-order">Inverse Order</a></h3>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>node&lt;inverse&gt; print_attrs("NAME")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">NAME = "tenessee"
NAME = "ohio"
NAME = "red"
NAME = "arkansas"
NAME = "missouri"
NAME = "upper-mississippi"
NAME = "lower-mississippi"
</code></pre>
<h2 id="list-of-nodes"><a class="header" href="#list-of-nodes">List of Nodes</a></h2>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>node[tenessee,"lower-mississippi"] print_attrs("NAME")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">NAME = "lower-mississippi"
NAME = "tenessee"
</code></pre>
<h2 id="path-of-nodes"><a class="header" href="#path-of-nodes">Path of Nodes</a></h2>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>node[tenessee -&gt; "lower-mississippi"] print_attrs("NAME")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">NAME = "tenessee"
NAME = "ohio"
NAME = "lower-mississippi"
</code></pre>
<p>As we can see in the diagram, the path from tenessee to lower
mississippi includes the ohio node.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-function"><a class="header" href="#network-function">Network Function</a></h1>
<p>Network function runs on the network as a whole. It takes arguments and keyword arguments. Few network functions we have been using throughout the examples are <code>load_file</code>, <code>load_str</code> and <code>svg_save</code>:</p>
<pre><code class="language-task">network load_file("./data/mississippi.net")
<span class="boring">network command("mkdir -p output")
</span>network svg_save(
   "./output/network-mississippi-sdf.svg",
	label="[{INDEX}] {_NAME:repl(-, ):case(title)}",
	bgcolor="gray"
)
</code></pre>
<p>Results:</p>
<center>  
<p><img src="intro/../output/network-mississippi-sdf.svg" alt="" /></p>
</center>  
<div class="warning">
The examples below use the graphviz plugin. Make sure you have it loaded. Refer to the plugins section to learn how to load the plugins in to the Nadi System.
</div>
<p>For example following network function takes file path as input to save the network in graphviz format:</p>
<pre><code class="language-sig">save_graphviz(
	outfile [PathBuf],
	name [String] = "network",
	global_attrs [String] = "",
	node_attr [Option &lt; Template &gt;],
	edge_attr [Option &lt; Template &gt;]
)
</code></pre>
<p>Note that, if the arguments have default values, or are optional, then you do not need to provide them.</p>
<p>For example, you can simply call the above function like this.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>network save_graphviz("./output/test.gv")
<span class="boring">network clip()
</span><span class="boring"># the path link are relative to /src
</span><span class="boring">network echo("./output/test.gv")
</span></code></pre>
<p>Results:</p>
<pre><code class="language-output">digraph network {

"upper-mississippi" -&gt; "lower-mississippi"
"missouri" -&gt; "lower-mississippi"
"arkansas" -&gt; "lower-mississippi"
"red" -&gt; "lower-mississippi"
"ohio" -&gt; "lower-mississippi"
"tenessee" -&gt; "ohio"
}
</code></pre>
<p>With extra commands you can also convert it into an image</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span><span class="boring">network save_graphviz("./output/test.gv")
</span>network command("dot -Tsvg ./output/test.gv -o ./output/test.svg")
<span class="boring">network clip()
</span><span class="boring"># the link path needs to be relative to this file
</span><span class="boring">network echo("../output/test.svg")
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="intro/../output/test.svg" alt="" /></p>
</center>  
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-context-functions-and-variables"><a class="header" href="#cross-context-functions-and-variables">Cross Context Functions and Variables</a></h1>
<p>You can access variable and call functions based on their default context (e.g. node variable/function in a node task). Additionally, you can also access the variables or call functions in select few other context.</p>
<p>By default, if a function is not available, node/network task calls the environment function of the same name.</p>
<p>For example, here the <code>sum</code> and <code>array</code> functions are environment functions, while the <code>count</code> is a network function. When you use Nadi IDE, it’ll show you which function is actually being called at the top of the editor.</p>
<pre><code class="language-task">network load_str("a-&gt;b")
network sum(array(count(), 1))
</code></pre>
<p>Results:</p>
<pre><code class="language-output">3
</code></pre>
<p>Besides this, you can manually call cross context variable/functions in the following ways:</p>
<h2 id="env-and-network-variablesfunctions"><a class="header" href="#env-and-network-variablesfunctions">Env and Network Variables/Functions</a></h2>
<p>You can use <code>env</code> and <code>network</code> variables anywhere in the task system with the dot syntax.</p>
<pre><code class="language-task"><span class="boring"> network load_str("a-&gt;b")
</span>env.var = 12;
network.sth = true;

env render("this is {x}", x = network.sth)
network str(env.var)
node array(network.sth, env.var, node.NAME)
</code></pre>
<p>Results:</p>
<pre><code class="language-output">"this is true"
"12"
{
  b = [true, 12, "b"],
  a = [true, 12, "a"]
}
</code></pre>
<p>Similary, env and network functions can be called anywhere. These functions cannot be mutable functions (change network internally).</p>
<p>Taking the previous example, if we use env function <code>count</code>, we get an error as the function arguments are different.</p>
<pre><code class="language-task">network load_str("a-&gt;b")
node network.count()
network sum(array(env.count(), 1))
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">{
  b = 2,
  a = 2
}
Error in function count: Argument 1 (vars [&amp; [bool]]) is required
</code></pre>
<h2 id="node-variablesfunctions"><a class="header" href="#node-variablesfunctions">Node Variables/Functions</a></h2>
<p>You can use <code>node</code>, <code>inputs</code>, <code>output</code> and <code>nodes</code> keywords to access node variables and functions from different contexts. <code>nodes</code> is valid in all tasks, while the other 3 are only valid in a node task and refer to the current node, input nodes and output node respectively.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>env count(nodes._)
node inputs.NAME
</code></pre>
<p>Results:</p>
<pre><code class="language-output">7
{
  lower-mississippi = ["ohio", "upper-mississippi", "missouri", "arkansas", "red"],
  upper-mississippi = [],
  missouri = [],
  arkansas = [],
  red = [],
  ohio = ["tenessee"],
  tenessee = []
}
</code></pre>
<p>You can call node functions not just for the node in the context, but also for input nodes, and output node:</p>
<p>Please note that the root node (outlet) of the network doesn’t have output node, so we need to skip that, which can be done through the <code>output._?</code> which is checking for the dummy variable <code>_</code> in <code>output</code>, which is true if the node has an output.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>node[tenessee -&gt; "lower-mississippi"] inputs.render("{_NAME}")
node[tenessee -&gt; "lower-mississippi"](output._?) output.render("{_NAME}")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  tenessee = [],
  ohio = ["tenessee"],
  lower-mississippi = ["ohio", "upper-mississippi", "missouri", "arkansas", "red"]
}
{
  tenessee = "ohio",
  ohio = "lower-mississippi"
}
</code></pre>
<p>You can also use <code>nodes</code> keyword to call the function on each node, it can be used anywhere, but is useful for env and network tasks.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>
env nodes.render("Node [{INDEX}] {_NAME}")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">["Node [0] lower-mississippi", "Node [1] upper-mississippi", "Node [2] missouri", "Node [3] arkansas", "Node [4] red", "Node [5] ohio", "Node [6] tenessee"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins-1"><a class="header" href="#plugins-1">Plugins</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h1>
<p>If you need help on any functions. Use the <code>help</code> as a <code>task</code>. You can use <code>help node</code> or <code>help network</code> for specific help. You can also browse through the function help window in the <code>nadi-ide</code> for help related to each functions.</p>
<pre><code class="language-task">help node render
</code></pre>
<p>Results:</p>
<pre><code class="language-output">node render (template: '&amp; Template', safe: 'bool' = false)
Render the template based on the node attributes
# Arguments
- `template: &amp; Template` String template to render
- `safe: bool` [def = false] if render fails keep it as it is instead of exiting


For more details on the template system. Refer to the String
Template section of the NADI book.

```task
network load_str("a -&gt; b")
node.x = 13
node assert_eq(render("abc {x}"), "abc 13")
```
</code></pre>
<p>Or you can use <code>nadi --fnhelp &lt;function&gt;</code> using the <code>nadi-cli</code>.</p>
<p>Now that you have the overview of the nadi system’s data
structures. We’ll jump into the software structure and how to setup
and use the system.</p>
<p>If you want more details on any of the data structures refer the
Developer’s references, or the library documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learn-by-examples"><a class="header" href="#learn-by-examples">Learn by Examples</a></h1>
<p>For example data download the <a href="./data.zip">zip file here</a></p>
<div class="table-wrapper"><table><thead><tr><th>Topic</th><th>Learn About</th></tr></thead><tbody>
<tr><td><a href="./learn-examples/attributes.html">Attributes</a></td><td>Setting and Getting Attributes</td></tr>
<tr><td><a href="./learn-examples/control.html">Control Flow</a></td><td>Control flow, if, else, while loops etc</td></tr>
<tr><td><a href="./learn-examples/connections.html">Connections</a></td><td>Loading and modifying connections</td></tr>
<tr><td><a href="./learn-examples/counting.html">Counting</a></td><td>Counting nodes in network, conditional</td></tr>
<tr><td><a href="./learn-examples/cumulative.html">Cumulative</a></td><td>Calculating Network cumulative sums and those</td></tr>
<tr><td><a href="./learn-examples/import-export.html">Import Export</a></td><td>Importing and exporting multiple data formats</td></tr>
<tr><td><a href="./learn-examples/str-templates.html">String Template</a></td><td>Using String Templates to do various things</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="attributes-1"><a class="header" href="#attributes-1">Attributes</a></h1>
<p>There are 3 kind of attributes in nadi. Environment, Network and Node attributes. as their name suggests environment attributes are general attributes available in the current context. Network attributes are associated with the currenly loaded network. and node attributes are associated with each nodes.</p>
<p>nadi has special syntax where you can get/set attributes for multiple nodes at once.</p>
<pre><code class="language-task">network load_str("a -&gt; b\n b -&gt; d\n c -&gt; d\n");
# environmental attribute
env.someattr = 123;
env.other = 1998-12-21;
env array(someattr, other)
# network attribute
network.someattr = true;
network.someattr
# node attributes
node.someattr = "string val";

node.someattr
</code></pre>
<p>Results:</p>
<pre><code class="language-output">[123, 1998-12-21]
true
{
  d = "string val",
  c = "string val",
  b = "string val",
  a = "string val"
}
</code></pre>
<p>like you saw with the array function, variables used are inferred as the attributes of the current env/network/node task.</p>
<p>you can use attributes from outside of current task type in some cases like:</p>
<ul>
<li>env/network variables can be used anywhere</li>
<li>node variables are valid in node tasks</li>
<li>node tasks has special variables types like <code>inputs</code> and <code>output</code></li>
</ul>
<pre><code class="language-task">network load_str("a -&gt; b\n b -&gt; d\n c -&gt; d\n");
# environmental attribute
env.someattr = 123;
env.other = 1998-12-21;
# network attribute
network.someattr = true;

# using network attr in env task
env array(network.someattr, other)

# using nodes in network task
network nodes.NAME
</code></pre>
<p>Results:</p>
<pre><code class="language-output">[true, 1998-12-21]
["d", "c", "b", "a"]
</code></pre>
<p>Similarly inputs:</p>
<pre><code class="language-task">network load_str("a -&gt; b\n b -&gt; d\n c -&gt; d\n");

node inputs.NAME
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  d = ["b", "c"],
  c = [],
  b = ["a"],
  a = []
}
</code></pre>
<p>Refer to the network diagram below to verify the output are correct:</p>
<pre><code class="language-task">network load_str("a -&gt; b\n b -&gt; d\n c -&gt; d\n");
<span class="boring">network svg_save("./output/attrs-simp.svg")
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/attrs-simp.svg" alt="" /></p>
</center>  
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Task has some basic control flow required to write programs. They are if-else branches and while loops.</p>
<h2 id="conditional-if-else-blocks"><a class="header" href="#conditional-if-else-blocks">Conditional (If-Else) Blocks</a></h2>
<p>There are two kind of if-else branches. One is on an expression level. which means there has to be if and else branch both as it expects a return value. The following example shows the expression with if-else block.</p>
<pre><code class="language-task">env.newvar = if (12 &gt; 90) {"yes"} else {"no"};
env.newvar
</code></pre>
<p>Results:</p>
<pre><code class="language-output">"no"
</code></pre>
<p>Trying to do it without else block will result in an parse error as the program will error with a syntax error, for example the code below is invalid</p>
<pre><code class="language-task">env.newvar = if (12 &gt; 90) {"yes"};
env.newvar
</code></pre>
<p>That’s when you can use the if-else block on the task level. This can be only if block as the execution blocks are tasks instead of expressions.</p>
<p>Here, since the condition is negative the task inside the block is never executed, hence <code>env.newvar</code> is empty.</p>
<pre><code class="language-task">if (12 &gt; 90) {
	env.newvar = "yes";
}
env.newvar
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">EvalError: Attribute not found
</code></pre>
<h2 id="while-loop"><a class="header" href="#while-loop">While Loop</a></h2>
<p>While loop runs the tasks inside the block repeatedly while the condition is satisfied. There is an iteration limit of 1,000,000 for now just in case people write infinite loop. This is arbritary.</p>
<pre><code class="language-task">env.somevar = 1;
while (somevar &lt; 10) {
	env.somevar
	env.somevar = env.somevar + 1;
}
</code></pre>
<p>Results:</p>
<pre><code class="language-output">1
2
3
4
5
6
7
8
9
</code></pre>
<p>This can be used to repeat a set of tasks for a various reasons.</p>
<div class="warning">
If your tasks take a long time to run, note that, the while loop needs to be completely run before the output can be processed and displayed, so that even if your output is not printed, it is being run. This will be fixed in the future version of the program.
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connections"><a class="header" href="#connections">Connections</a></h1>
<p>Connections between the nodes is the most important part of nadi. you can load networks by loading a file or string. The network is a simple multiline text with one edge (<code>input -&gt; output</code>) in each line. comments starting with <code>#</code> are supported.</p>
<h2 id="default-is-empty-network"><a class="header" href="#default-is-empty-network">Default is Empty Network</a></h2>
<p>Tasks are run by default with an empty network. So you might still be able to work with network attributes, but the nodes will be empty. also note that when you load network it replaces the old one including the attributes.</p>
<pre><code class="language-task">network.someattr = 1234;
network.someattr
</code></pre>
<p>Results:</p>
<pre><code class="language-output">1234
</code></pre>
<p>But we can see the nodes are not there,</p>
<pre><code class="language-task">network count()
network nodes.NAME
</code></pre>
<p>Results:</p>
<pre><code class="language-output">0
[]
</code></pre>
<p>Trying to run node functions on the empty network means nothing is run</p>
<pre><code class="language-task">node render("{NAME}")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">
</code></pre>
<h2 id="loading-network-from-string"><a class="header" href="#loading-network-from-string">Loading Network from String</a></h2>
<p>Here assume we have a network consisting of nodes of dams and gages like the following where dam nodes start with d and gages with g:</p>
<pre><code class="language-task">network load_str("
d1 -&gt; d2
d3 -&gt; g2
d2 -&gt; g1
g1 -&gt; d4
g2 -&gt; d4
d4 -&gt; g3
");
<span class="boring">network svg_save(
</span><span class="boring">   "./output/simple-count.svg",
</span><span class="boring">	label="[{INDEX}] {_NAME}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/simple-count.svg" alt="" /></p>
</center>  
<h2 id="loading-network-from-a-file"><a class="header" href="#loading-network-from-a-file">Loading Network from a File</a></h2>
<p>we can load a network from a file:</p>
<pre><code class="language-task">network load_file("./data/mississippi.net");
<span class="boring">network svg_save(
</span><span class="boring">   "./output/ex-network-conn.svg",
</span><span class="boring">	label="[{INDEX}] {_NAME}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/ex-network-conn.svg" alt="" /></p>
</center>  
<h2 id="modifying-the-network"><a class="header" href="#modifying-the-network">Modifying the network</a></h2>
<p>You can modify the network after loading it as well. The example below extracts just the nodes that are dams. Compare this with the previous network to see how the connections are retained during the subsets.</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span><span class="boring">d1 -&gt; d2
</span><span class="boring">d3 -&gt; g2
</span><span class="boring">d2 -&gt; g1
</span><span class="boring">g1 -&gt; d4
</span><span class="boring">g2 -&gt; d4
</span><span class="boring">d4 -&gt; g3
</span><span class="boring">");
</span>node.is_dam = NAME match "^d[0-9]+";
network subset(nodes.is_dam);
<span class="boring">network svg_save(
</span><span class="boring">   "./output/simple-count-subset.svg",
</span><span class="boring">	label="[{INDEX}] {_NAME}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/simple-count-subset.svg" alt="" /></p>
</center>  
<p>This can be useful when you want to remove nodes that do not satisfy some selection criteria for your analysis without having to redo the network detection part.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting-nodes"><a class="header" href="#counting-nodes">Counting Nodes</a></h1>
<p>Here assume we have a network consisting of nodes of dams and gages like the following where dam nodes start with d and gages with g:</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span>d1 -&gt; d2
d3 -&gt; g2
d2 -&gt; g1
g1 -&gt; d4
g2 -&gt; d4
d4 -&gt; g3
<span class="boring">");
</span><span class="boring">network svg_save(
</span><span class="boring">   "./output/simple-count.svg",
</span><span class="boring">	label="[{INDEX}] {_NAME}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/simple-count.svg" alt="" /></p>
</center>  
<p>Simply counting number of nodes, or certain types of nodes in a network is done through <code>count</code> function.</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span><span class="boring">d1 -&gt; d2
</span><span class="boring">d3 -&gt; g2
</span><span class="boring">d2 -&gt; g1
</span><span class="boring">g1 -&gt; d4
</span><span class="boring">g2 -&gt; d4
</span><span class="boring">d4 -&gt; g3
</span><span class="boring">");
</span>node.g_node = NAME match "^g[0-9]+";
network count()
network count(nodes.g_node)
network count(nodes.g_node) / count()
</code></pre>
<p>Results:</p>
<pre><code class="language-output">7
3
0.42857142857142855
</code></pre>
<p>when you call a network function, you get one output, while a node function will give you the output for each node like here:</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span><span class="boring">d1 -&gt; d2
</span><span class="boring">d3 -&gt; g2
</span><span class="boring">d2 -&gt; g1
</span><span class="boring">g1 -&gt; d4
</span><span class="boring">g2 -&gt; d4
</span><span class="boring">d4 -&gt; g3
</span><span class="boring">");
</span>node.g_node = NAME match "^g[0-9]+";
node.g_node
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  g3 = true,
  d4 = false,
  g2 = true,
  d3 = false,
  g1 = true,
  d2 = false,
  d1 = false
}
</code></pre>
<p>Always be careful that node function is run for all the nodes separately, if you are running them without any variables from the node, then you can use network function, or environment function to get the results.</p>
<p>Counting the number of nodes upstream of each node gives us the order of the nodes.</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span><span class="boring">d1 -&gt; d2
</span><span class="boring">d3 -&gt; g2
</span><span class="boring">d2 -&gt; g1
</span><span class="boring">g1 -&gt; d4
</span><span class="boring">g2 -&gt; d4
</span><span class="boring">d4 -&gt; g3
</span><span class="boring">");
</span>node&lt;inputsfirst&gt;.nodes_us = 1 + sum(inputs.nodes_us);
<span class="boring">network svg_save(
</span><span class="boring">   "./output/simple-count-1.svg",
</span><span class="boring">	label="{_NAME} = {nodes_us}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/simple-count-1.svg" alt="" /></p>
</center>  
<p>We can add a condition and count the nodes that satisfy that condition only. Like counting the number of dams upstream of each node (including the node).</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span><span class="boring">d1 -&gt; d2
</span><span class="boring">d3 -&gt; g2
</span><span class="boring">d2 -&gt; g1
</span><span class="boring">g1 -&gt; d4
</span><span class="boring">g2 -&gt; d4
</span><span class="boring">d4 -&gt; g3
</span><span class="boring">");
</span>node.is_dam = NAME match "^d[0-9]+";
node&lt;inputsfirst&gt;.dams_us = int(is_dam) + sum(inputs.dams_us);
<span class="boring">network svg_save(
</span><span class="boring">   "./output/simple-count-2.svg",
</span><span class="boring">	label="{_NAME} = {dams_us}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/simple-count-2.svg" alt="" /></p>
</center>  
<p>You can similarly count the number of gages downstream. Here we need a conditional unlike in previous cases as not all nodes have output. In case of inputs, a leaf node would have no inputs but <code>sum([])</code> would still be a valid output of <code>0</code>. But for node without output nodes, the variable type <code>output</code> fails with <code>NoOutputNode</code> error, so we add a conditional check to avoid that.</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span><span class="boring">d1 -&gt; d2
</span><span class="boring">d3 -&gt; g2
</span><span class="boring">d2 -&gt; g1
</span><span class="boring">g1 -&gt; d4
</span><span class="boring">g2 -&gt; d4
</span><span class="boring">d4 -&gt; g3
</span><span class="boring">");
</span>node.is_gage = NAME match "^g[0-9]+";
node&lt;outputfirst&gt;.gages_ds = int(is_gage) + if (output._?) {
	output.gages_ds
	} else {
	0
};
<span class="boring">network svg_save(
</span><span class="boring">   "./output/simple-count-3.svg",
</span><span class="boring">	label="{_NAME} = {gages_ds}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/simple-count-3.svg" alt="" /></p>
</center>  
<p>Here the condition <code>(output._?)</code> checks if there is output on the node or not by checking for the dummy variable <code>_</code> which is present in all nodes/network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cumulative-sum"><a class="header" href="#cumulative-sum">Cumulative Sum</a></h1>
<p>Here we can use the stream ordering formula to calculate the stream order for each node:</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span><span class="boring">d1 -&gt; d2
</span><span class="boring">d3 -&gt; g1
</span><span class="boring">d2 -&gt; g1
</span><span class="boring">g1 -&gt; d4
</span><span class="boring">g2 -&gt; d4
</span><span class="boring">d4 -&gt; g3
</span><span class="boring">");
</span>node&lt;inputsfirst&gt;.stream_ord = max(inputs.stream_ord, 1) + int(count(inputs._?) &gt; 1);
<span class="boring">network svg_save(
</span><span class="boring">   "./output/cumulative-1.svg",
</span><span class="boring">	label="{_NAME} = {stream_ord}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/cumulative-1.svg" alt="" /></p>
</center>  
<p>The first part takes the maximum order of the input nodes, then the second part <code>int(count(inputs._?) &gt; 1)</code> checks if there are more than one input, adding one to the order when multiple streams combine into one. You can use the funciton <code>inputs_count()</code> instead of <code>count(inputs._?)</code> to do the same thing.</p>
<p>That is the core of the NADI Task System, you can write functions that have their own logic and then load them into the system. You can then use the syntax and network based analysis methods of NADI using those functions.</p>
<p>And of course, we can visualize the different order of streams for easier understanding.</p>
<pre><code class="language-task"><span class="boring">network load_str("
</span><span class="boring">d1 -&gt; d2
</span><span class="boring">d3 -&gt; g1
</span><span class="boring">d2 -&gt; g1
</span><span class="boring">g1 -&gt; d4
</span><span class="boring">g2 -&gt; d4
</span><span class="boring">d4 -&gt; g3
</span><span class="boring">");
</span><span class="boring">node&lt;inputsfirst&gt;.stream_ord = max(inputs.stream_ord, 1) + int(count(inputs._?) &gt; 1);
</span>node.visual.linewidth = stream_ord / 2;
node(stream_ord == 1).visual.linecolor = "green";
node(stream_ord == 2).visual.linecolor = "blue";
node(stream_ord == 3).visual.linecolor = "red";
<span class="boring">network svg_save(
</span><span class="boring">   "./output/cumulative-2.svg",
</span><span class="boring">	label="{_NAME} = {stream_ord}"
</span><span class="boring">)
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/cumulative-2.svg" alt="" /></p>
</center>  
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-export-files"><a class="header" href="#import-export-files">Import Export Files</a></h1>
<p>Similar to how you can load network files, you can load attributes from files as well. Direct load of TOML format is supported from the internal plugins, while you might need external plugins for other formats.</p>
<p><code>load_attrs</code> function takes a template, and reads a different files for each node to load the attributes from.</p>
<pre><code class="language-task">network load_file("data/ohio.network")
node attributes.load_attrs("data/attrs/{_NAME}.toml")
network svg_save(
<span class="boring">  "output/ohio-import-export.svg",
</span>  label="{_NAME} (A = {basin_area?:f(2)})",
<span class="boring">  height=700,
</span>  bgcolor="gray"
)
</code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/ohio-import-export.svg" alt="" /></p>
</center>  
<p>You can use the render function to see if the files being loaded are correct. Here we can see the examples for the first 4 nodes:</p>
<pre><code class="language-task"><span class="boring">network load_file("data/ohio.network")
</span>node(INDEX&lt;4) render("data/attrs/{_NAME}.toml")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  smithland = "data/attrs/smithland.toml",
  golconda = "data/attrs/golconda.toml",
  old-shawneetown = "data/attrs/old-shawneetown.toml",
  mountcarmel = "data/attrs/mountcarmel.toml"
}
</code></pre>
<p>You can also read a attributes from string, so you can combine that with <code>files.from_file</code> and load it.</p>
<pre><code class="language-task">network load_file("data/ohio.network")
env.somevalue = attributes.parse_attrmap(
	files.from_file("data/attrs/smithland.toml")
);
env.somevalue.basin_area
env.somevalue.length
</code></pre>
<p>Results:</p>
<pre><code class="language-output">371802.16
1675.95
</code></pre>
<p>You can export csv files</p>
<pre><code class="language-task">network load_file("data/ohio.network")
node attributes.load_attrs("data/attrs/{_NAME}.toml")
network table.save_csv("output/ohio-export.csv", ["NAME", "basin_area", "length"])
network command("cat output/ohio-export.csv | head", echo=true)
</code></pre>
<p>Results:</p>
<pre><code class="language-output">$ cat output/ohio-export.csv | head
NAME,basin_area,length
"smithland",371802.16,1675.95
"golconda",370942.26,1701.32
"old-shawneetown",363656.85,1772.27
"mountcarmel",74359.92,1918.08
"jt-myers",277962.45,1791.07
"evansville",275482.9,1878.29
"calhoun",18540.88,1992.5
"newburgh",253065.62,1903.58
"cannelton",249382.5,1993.72
</code></pre>
<h2 id="gis-files"><a class="header" href="#gis-files">GIS Files</a></h2>
<div class="warning">
The examples below require the `gis` external plugin from `nadi-gis` repository to work. Make sure you have the plugin file in the directory in your `NADI_PLUGIN_DIRS` environmental variable.
</div>
<p>First we make a GIS file by exporting. The image below shows the resulting points (red) from the shapefile and connections (black) from the Geopackage file when we visualize this on QGIS (with background of Terrain and Ohio River tributaries).</p>
<pre><code class="language-task">network load_file("data/ohio.network")
node attributes.load_attrs("data/attrs/{_NAME}.toml")
node.geometry = render("POINT ({lon} {lat})");
network gis.gis_save_nodes(
  "output/ohio-nodes.shp",
  "geometry",
  {
    NAME = "String",
	basin_area = "Float",
	length = "Float"
  }
)
# Exporting the edges
network gis.gis_save_connections(
  "output/ohio-connections.gpkg",
  "geometry"
)
</code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../images/ohio-nodes.png" alt="" /></p>
</center>  
<p>The geometry attributes should be <a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">WKT String</a>.</p>
<!-- node(output._?).out_lon = output.lon; -->
<!-- node(output._?).out_lat = output.lat; -->
<!-- node(output._?).edge_geom = render("LINESTRING ({lon} {lat}, {out_lon} {out_lat})"); -->
<p>Now we are using the generated GIS files to load the network and the attributes:</p>
<pre><code class="language-task">network gis.gis_load_network("output/ohio-connections.gpkg", "start", "end")
network gis.gis_load_attrs("output/ohio-nodes.shp", "NAME")

network svg_save(
<span class="boring">  "output/ohio-from-gis.svg",
</span>  label="{_NAME} (A = {basin_area?:f(2)}; L = {length:f(1)})",
<span class="boring">  height=700,
</span>  bgcolor="gray"
)
</code></pre>
<p>Results:</p>
<center>  
<p><img src="learn-examples/../output/ohio-from-gis.svg" alt="" /></p>
</center>  
<p>As we can see the plugins make it easier to interoperate with a lot of different data formats. Here GIS plugin will support any file types supported by <code>gdal</code>. Similarly, other formats can be supported by writing plugins.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-templates"><a class="header" href="#string-templates">String Templates</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nadi-extension-capabilities"><a class="header" href="#nadi-extension-capabilities">Nadi Extension Capabilities</a></h1>
<p>Nadi System can be extended for custom use cases with the following ways:</p>
<ul>
<li><a href="system/../devref/string-templates.html#advanced-string-template-with-lisp">LISP on String Template</a></li>
<li>Task System</li>
<li>Rust Library</li>
<li>Python Library</li>
<li>Plugin System</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="all-plugin-functions"><a class="header" href="#all-plugin-functions">All Plugin Functions</a></h1>
<p>All the functions available on this instance of nadi, are listed here.</p>
<h2 id="env-functions"><a class="header" href="#env-functions">Env Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Plugin</th><th style="text-align: left">Function</th><th style="text-align: left">Help</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.exp"><code>exp</code></a></td><td style="text-align: left">Exponential</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.float_div"><code>float_div</code></a></td><td style="text-align: left">Float Division (same as / operator)</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.float_mult"><code>float_mult</code></a></td><td style="text-align: left">Float Multiplication (same as * operator)</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.get"><code>get</code></a></td><td style="text-align: left">get the choosen attribute from Array or AttrMap</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.log"><code>log</code></a></td><td style="text-align: left">Logarithm of a value, natural if base not given</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.parse_attr"><code>parse_attr</code></a></td><td style="text-align: left">Parse attribute from string</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.parse_attrmap"><code>parse_attrmap</code></a></td><td style="text-align: left">Parse attribute from string</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.powf"><code>powf</code></a></td><td style="text-align: left">Float power</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.powi"><code>powi</code></a></td><td style="text-align: left">Integer power</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.sqrt"><code>sqrt</code></a></td><td style="text-align: left">Square Root</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#env.strmap"><code>strmap</code></a></td><td style="text-align: left">map values from the attribute based on the given table</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.append"><code>append</code></a></td><td style="text-align: left">append a value to an array</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.array"><code>array</code></a></td><td style="text-align: left">make an array from the arguments</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.assert_eq"><code>assert_eq</code></a></td><td style="text-align: left">Assert the two values are equal</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.assert_neq"><code>assert_neq</code></a></td><td style="text-align: left">Assert the two values are not equal</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.assert"><code>assert</code></a></td><td style="text-align: left">Assert the condition is true</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.attrmap"><code>attrmap</code></a></td><td style="text-align: left">make an attrmap from the arguments</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.concat"><code>concat</code></a></td><td style="text-align: left">Concat the strings</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.count_str"><code>count_str</code></a></td><td style="text-align: left">Get a count of unique string values</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.count"><code>count</code></a></td><td style="text-align: left">Count the number of true values in the array</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.day"><code>day</code></a></td><td style="text-align: left">day from date/datetime</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.float"><code>float</code></a></td><td style="text-align: left">make a float from value</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.int"><code>int</code></a></td><td style="text-align: left">make an int from the value</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.isinf"><code>isinf</code></a></td><td style="text-align: left">check if a float is +/- infinity</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.isna"><code>isna</code></a></td><td style="text-align: left">check if a float is nan</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.json"><code>json</code></a></td><td style="text-align: left">format the attribute as a json string</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.length"><code>length</code></a></td><td style="text-align: left">length of an array or hashmap</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.max_num"><code>max_num</code></a></td><td style="text-align: left">Minimum of the variables</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.max"><code>max</code></a></td><td style="text-align: left">Maximum of the variables</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.min_num"><code>min_num</code></a></td><td style="text-align: left">Minimum of the variables</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.min"><code>min</code></a></td><td style="text-align: left">Minimum of the variables</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.month"><code>month</code></a></td><td style="text-align: left">month from date/datetime</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.prod"><code>prod</code></a></td><td style="text-align: left">Product of the variables</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.range"><code>range</code></a></td><td style="text-align: left">Generate integer array, end is not included</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.str"><code>str</code></a></td><td style="text-align: left">make a string from value</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.sum"><code>sum</code></a></td><td style="text-align: left">Sum of the variables</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.type_name"><code>type_name</code></a></td><td style="text-align: left">Type name of the arguments</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.unique_str"><code>unique_str</code></a></td><td style="text-align: left">Get a list of unique string values</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#env.year"><code>year</code></a></td><td style="text-align: left">year from date/datetime</td></tr>
<tr><td style="text-align: left"><a href="plugins/debug.html"><code>debug</code></a></td><td style="text-align: left"><a href="plugins/debug.html#env.clip"><code>clip</code></a></td><td style="text-align: left">Echo the ––8&lt;–– line for clipping syntax</td></tr>
<tr><td style="text-align: left"><a href="plugins/debug.html"><code>debug</code></a></td><td style="text-align: left"><a href="plugins/debug.html#env.debug"><code>debug</code></a></td><td style="text-align: left">Print the args and kwargs on this function</td></tr>
<tr><td style="text-align: left"><a href="plugins/debug.html"><code>debug</code></a></td><td style="text-align: left"><a href="plugins/debug.html#env.echo"><code>echo</code></a></td><td style="text-align: left">Echo the string to stdout or stderr</td></tr>
<tr><td style="text-align: left"><a href="plugins/debug.html"><code>debug</code></a></td><td style="text-align: left"><a href="plugins/debug.html#env.sleep"><code>sleep</code></a></td><td style="text-align: left">sleep for given number of milliseconds</td></tr>
<tr><td style="text-align: left"><a href="plugins/dss.html"><code>dss</code></a></td><td style="text-align: left"><a href="plugins/dss.html#env.list_catalog"><code>list_catalog</code></a></td><td style="text-align: left">List the catalog of the dss file</td></tr>
<tr><td style="text-align: left"><a href="plugins/files.html"><code>files</code></a></td><td style="text-align: left"><a href="plugins/files.html#env.exists"><code>exists</code></a></td><td style="text-align: left">Checks if the given path exists</td></tr>
<tr><td style="text-align: left"><a href="plugins/files.html"><code>files</code></a></td><td style="text-align: left"><a href="plugins/files.html#env.from_file"><code>from_file</code></a></td><td style="text-align: left">Reads the file contents as string</td></tr>
<tr><td style="text-align: left"><a href="plugins/files.html"><code>files</code></a></td><td style="text-align: left"><a href="plugins/files.html#env.to_file"><code>to_file</code></a></td><td style="text-align: left">Writes the string to the file</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.all"><code>all</code></a></td><td style="text-align: left">check if all of the bool are true</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.and"><code>and</code></a></td><td style="text-align: left">Boolean and</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.any"><code>any</code></a></td><td style="text-align: left">check if any of the bool are true</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.eq"><code>eq</code></a></td><td style="text-align: left">Equality than check</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.gt"><code>gt</code></a></td><td style="text-align: left">Greater than check</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.ifelse"><code>ifelse</code></a></td><td style="text-align: left">Simple if else condition</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.lt"><code>lt</code></a></td><td style="text-align: left">Less than check</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.not"><code>not</code></a></td><td style="text-align: left">boolean not</td></tr>
<tr><td style="text-align: left"><a href="plugins/logic.html"><code>logic</code></a></td><td style="text-align: left"><a href="plugins/logic.html#env.or"><code>or</code></a></td><td style="text-align: left">boolean or</td></tr>
<tr><td style="text-align: left"><a href="plugins/nadi_pdf.html"><code>nadi_pdf</code></a></td><td style="text-align: left"><a href="plugins/nadi_pdf.html#env.typst_compile"><code>typst_compile</code></a></td><td style="text-align: left">convert the typst content into pdf/svg/png</td></tr>
<tr><td style="text-align: left"><a href="plugins/regex.html"><code>regex</code></a></td><td style="text-align: left"><a href="plugins/regex.html#env.str_count"><code>str_count</code></a></td><td style="text-align: left">Count the number of matches of given pattern in the string</td></tr>
<tr><td style="text-align: left"><a href="plugins/regex.html"><code>regex</code></a></td><td style="text-align: left"><a href="plugins/regex.html#env.str_filter"><code>str_filter</code></a></td><td style="text-align: left">Filter from the string list with only the values matching pattern</td></tr>
<tr><td style="text-align: left"><a href="plugins/regex.html"><code>regex</code></a></td><td style="text-align: left"><a href="plugins/regex.html#env.str_find_all"><code>str_find_all</code></a></td><td style="text-align: left">Find all the matches of the given pattern in the value</td></tr>
<tr><td style="text-align: left"><a href="plugins/regex.html"><code>regex</code></a></td><td style="text-align: left"><a href="plugins/regex.html#env.str_find"><code>str_find</code></a></td><td style="text-align: left">Find the given pattern in the value</td></tr>
<tr><td style="text-align: left"><a href="plugins/regex.html"><code>regex</code></a></td><td style="text-align: left"><a href="plugins/regex.html#env.str_match"><code>str_match</code></a></td><td style="text-align: left">Check if the given pattern matches the value or not</td></tr>
<tr><td style="text-align: left"><a href="plugins/regex.html"><code>regex</code></a></td><td style="text-align: left"><a href="plugins/regex.html#env.str_replace"><code>str_replace</code></a></td><td style="text-align: left">Replace the occurances of the given match</td></tr>
<tr><td style="text-align: left"><a href="plugins/regex.html"><code>regex</code></a></td><td style="text-align: left"><a href="plugins/regex.html#env.str_split"><code>str_split</code></a></td><td style="text-align: left">Split the string with the given pattern</td></tr>
<tr><td style="text-align: left"><a href="plugins/render.html"><code>render</code></a></td><td style="text-align: left"><a href="plugins/render.html#env.render"><code>render</code></a></td><td style="text-align: left">Render the template based on the node attributes</td></tr>
</tbody></table>
</div>
<h2 id="node-functions"><a class="header" href="#node-functions">Node Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Plugin</th><th style="text-align: left">Function</th><th style="text-align: left">Help</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.first_attr"><code>first_attr</code></a></td><td style="text-align: left">Return the first Attribute that exists</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.get_attr"><code>get_attr</code></a></td><td style="text-align: left">Retrive attribute</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.has_attr"><code>has_attr</code></a></td><td style="text-align: left">Check if the attribute is present</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.load_attrs"><code>load_attrs</code></a></td><td style="text-align: left">Loads attrs from file for all nodes based on the given template</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.load_toml_render"><code>load_toml_render</code></a></td><td style="text-align: left">Set node attributes by loading a toml from rendered template</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.print_all_attrs"><code>print_all_attrs</code></a></td><td style="text-align: left">Print all attrs in a node</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.print_attrs"><code>print_attrs</code></a></td><td style="text-align: left">Print the given node attributes if present</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.set_attrs_ifelse"><code>set_attrs_ifelse</code></a></td><td style="text-align: left">if else condition with multiple attributes</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.set_attrs_render"><code>set_attrs_render</code></a></td><td style="text-align: left">Set node attributes based on string templates</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#network.set_attrs"><code>set_attrs</code></a></td><td style="text-align: left">Set node attributes</td></tr>
<tr><td style="text-align: left"><a href="plugins/command.html"><code>command</code></a></td><td style="text-align: left"><a href="plugins/command.html#network.command"><code>command</code></a></td><td style="text-align: left">Run the given template as a shell command.</td></tr>
<tr><td style="text-align: left"><a href="plugins/command.html"><code>command</code></a></td><td style="text-align: left"><a href="plugins/command.html#network.run"><code>run</code></a></td><td style="text-align: left">Run the node as if it’s a command if inputs are changed</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#network.has_outlet"><code>has_outlet</code></a></td><td style="text-align: left">Node has an outlet or not</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#network.inputs_attr"><code>inputs_attr</code></a></td><td style="text-align: left">Get attributes of the input nodes</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#network.inputs_count"><code>inputs_count</code></a></td><td style="text-align: left">Count the number of input nodes in the node</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#network.output_attr"><code>output_attr</code></a></td><td style="text-align: left">Get attributes of the output node</td></tr>
<tr><td style="text-align: left"><a href="plugins/dams.html"><code>dams</code></a></td><td style="text-align: left"><a href="plugins/dams.html#network.count_node_if"><code>count_node_if</code></a></td><td style="text-align: left">Count the number of nodes upstream at each point that satisfies a certain condition</td></tr>
<tr><td style="text-align: left"><a href="plugins/dams.html"><code>dams</code></a></td><td style="text-align: left"><a href="plugins/dams.html#network.min_year"><code>min_year</code></a></td><td style="text-align: left">Propagate the minimum year downstream</td></tr>
<tr><td style="text-align: left"><a href="plugins/datafill.html"><code>datafill</code></a></td><td style="text-align: left"><a href="plugins/datafill.html#network.datafill_experiment"><code>datafill_experiment</code></a></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="plugins/datafill.html"><code>datafill</code></a></td><td style="text-align: left"><a href="plugins/datafill.html#network.load_csv_fill"><code>load_csv_fill</code></a></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="plugins/errors.html"><code>errors</code></a></td><td style="text-align: left"><a href="plugins/errors.html#network.calc_ts_error"><code>calc_ts_error</code></a></td><td style="text-align: left">Calculate Error from two timeseries values in the node</td></tr>
<tr><td style="text-align: left"><a href="plugins/errors.html"><code>errors</code></a></td><td style="text-align: left"><a href="plugins/errors.html#network.calc_ts_errors"><code>calc_ts_errors</code></a></td><td style="text-align: left">Calculate Error from two timeseries values in the node</td></tr>
<tr><td style="text-align: left"><a href="plugins/files.html"><code>files</code></a></td><td style="text-align: left"><a href="plugins/files.html#network.exists"><code>exists</code></a></td><td style="text-align: left">Checks if the given path exists when rendering the template</td></tr>
<tr><td style="text-align: left"><a href="plugins/print_node.html"><code>print_node</code></a></td><td style="text-align: left"><a href="plugins/print_node.html#network.print_node"><code>print_node</code></a></td><td style="text-align: left">Print the node with its inputs and outputs</td></tr>
<tr><td style="text-align: left"><a href="plugins/render.html"><code>render</code></a></td><td style="text-align: left"><a href="plugins/render.html#network.render"><code>render</code></a></td><td style="text-align: left">Render the template based on the node attributes</td></tr>
<tr><td style="text-align: left"><a href="plugins/series.html"><code>series</code></a></td><td style="text-align: left"><a href="plugins/series.html#network.set_series"><code>set_series</code></a></td><td style="text-align: left">set the following series to the node</td></tr>
<tr><td style="text-align: left"><a href="plugins/series.html"><code>series</code></a></td><td style="text-align: left"><a href="plugins/series.html#network.sr_count"><code>sr_count</code></a></td><td style="text-align: left">Number of series in the node</td></tr>
<tr><td style="text-align: left"><a href="plugins/series.html"><code>series</code></a></td><td style="text-align: left"><a href="plugins/series.html#network.sr_dtype"><code>sr_dtype</code></a></td><td style="text-align: left">Type name of the series</td></tr>
<tr><td style="text-align: left"><a href="plugins/series.html"><code>series</code></a></td><td style="text-align: left"><a href="plugins/series.html#network.sr_len"><code>sr_len</code></a></td><td style="text-align: left">Length of the series</td></tr>
<tr><td style="text-align: left"><a href="plugins/series.html"><code>series</code></a></td><td style="text-align: left"><a href="plugins/series.html#network.sr_list"><code>sr_list</code></a></td><td style="text-align: left">List all series in the node</td></tr>
<tr><td style="text-align: left"><a href="plugins/series.html"><code>series</code></a></td><td style="text-align: left"><a href="plugins/series.html#network.sr_mean"><code>sr_mean</code></a></td><td style="text-align: left">Type name of the series</td></tr>
<tr><td style="text-align: left"><a href="plugins/series.html"><code>series</code></a></td><td style="text-align: left"><a href="plugins/series.html#network.sr_sum"><code>sr_sum</code></a></td><td style="text-align: left">Sum of the series</td></tr>
<tr><td style="text-align: left"><a href="plugins/series.html"><code>series</code></a></td><td style="text-align: left"><a href="plugins/series.html#network.sr_to_array"><code>sr_to_array</code></a></td><td style="text-align: left">Make an array from the series</td></tr>
<tr><td style="text-align: left"><a href="plugins/streamflow.html"><code>streamflow</code></a></td><td style="text-align: left"><a href="plugins/streamflow.html#network.check_negative"><code>check_negative</code></a></td><td style="text-align: left">Check the given streamflow timeseries for negative values</td></tr>
<tr><td style="text-align: left"><a href="plugins/timeseries.html"><code>timeseries</code></a></td><td style="text-align: left"><a href="plugins/timeseries.html#network.ts_count"><code>ts_count</code></a></td><td style="text-align: left">Number of timeseries in the node</td></tr>
<tr><td style="text-align: left"><a href="plugins/timeseries.html"><code>timeseries</code></a></td><td style="text-align: left"><a href="plugins/timeseries.html#network.ts_dtype"><code>ts_dtype</code></a></td><td style="text-align: left">Type name of the timeseries</td></tr>
<tr><td style="text-align: left"><a href="plugins/timeseries.html"><code>timeseries</code></a></td><td style="text-align: left"><a href="plugins/timeseries.html#network.ts_len"><code>ts_len</code></a></td><td style="text-align: left">Length of the timeseries</td></tr>
<tr><td style="text-align: left"><a href="plugins/timeseries.html"><code>timeseries</code></a></td><td style="text-align: left"><a href="plugins/timeseries.html#network.ts_list"><code>ts_list</code></a></td><td style="text-align: left">List all timeseries in the node</td></tr>
<tr><td style="text-align: left"><a href="plugins/timeseries.html"><code>timeseries</code></a></td><td style="text-align: left"><a href="plugins/timeseries.html#network.ts_print"><code>ts_print</code></a></td><td style="text-align: left">Print the given timeseries values in csv format</td></tr>
</tbody></table>
</div>
<h2 id="network-functions"><a class="header" href="#network-functions">Network Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Plugin</th><th style="text-align: left">Function</th><th style="text-align: left">Help</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#node.set_attrs_render"><code>set_attrs_render</code></a></td><td style="text-align: left">Set network attributes based on string templates</td></tr>
<tr><td style="text-align: left"><a href="plugins/attributes.html"><code>attributes</code></a></td><td style="text-align: left"><a href="plugins/attributes.html#node.set_attrs"><code>set_attrs</code></a></td><td style="text-align: left">Set network attributes</td></tr>
<tr><td style="text-align: left"><a href="plugins/command.html"><code>command</code></a></td><td style="text-align: left"><a href="plugins/command.html#node.command"><code>command</code></a></td><td style="text-align: left">Run the given template as a shell command.</td></tr>
<tr><td style="text-align: left"><a href="plugins/command.html"><code>command</code></a></td><td style="text-align: left"><a href="plugins/command.html#node.parallel"><code>parallel</code></a></td><td style="text-align: left">Run the given template as a shell command for each nodes in the network in parallel.</td></tr>
<tr><td style="text-align: left"><a href="plugins/connections.html"><code>connections</code></a></td><td style="text-align: left"><a href="plugins/connections.html#node.load_edges"><code>load_edges</code></a></td><td style="text-align: left">Load the given edges into the network</td></tr>
<tr><td style="text-align: left"><a href="plugins/connections.html"><code>connections</code></a></td><td style="text-align: left"><a href="plugins/connections.html#node.load_file"><code>load_file</code></a></td><td style="text-align: left">Load the given file into the network</td></tr>
<tr><td style="text-align: left"><a href="plugins/connections.html"><code>connections</code></a></td><td style="text-align: left"><a href="plugins/connections.html#node.load_str"><code>load_str</code></a></td><td style="text-align: left">Load the given file into the network</td></tr>
<tr><td style="text-align: left"><a href="plugins/connections.html"><code>connections</code></a></td><td style="text-align: left"><a href="plugins/connections.html#node.save_file"><code>save_file</code></a></td><td style="text-align: left">Save the network into the given file</td></tr>
<tr><td style="text-align: left"><a href="plugins/connections.html"><code>connections</code></a></td><td style="text-align: left"><a href="plugins/connections.html#node.subset"><code>subset</code></a></td><td style="text-align: left">Take a subset of network by only including the selected nodes</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#node.count"><code>count</code></a></td><td style="text-align: left">Count the number of nodes in the network</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#node.node_attr"><code>node_attr</code></a></td><td style="text-align: left">Get the attr of the provided node</td></tr>
<tr><td style="text-align: left"><a href="plugins/core.html"><code>core</code></a></td><td style="text-align: left"><a href="plugins/core.html#node.outlet"><code>outlet</code></a></td><td style="text-align: left">Get the name of the outlet node</td></tr>
<tr><td style="text-align: left"><a href="plugins/datafill.html"><code>datafill</code></a></td><td style="text-align: left"><a href="plugins/datafill.html#node.save_experiments_csv"><code>save_experiments_csv</code></a></td><td style="text-align: left">Write the given nodes to csv with given attributes and experiment results</td></tr>
<tr><td style="text-align: left"><a href="plugins/errors.html"><code>errors</code></a></td><td style="text-align: left"><a href="plugins/errors.html#node.calc_attr_error"><code>calc_attr_error</code></a></td><td style="text-align: left">Calculate Error from two attribute values in the network</td></tr>
<tr><td style="text-align: left"><a href="plugins/fancy_print.html"><code>fancy_print</code></a></td><td style="text-align: left"><a href="plugins/fancy_print.html#node.fancy_print"><code>fancy_print</code></a></td><td style="text-align: left">Fancy print a network</td></tr>
<tr><td style="text-align: left"><a href="plugins/gis.html"><code>gis</code></a></td><td style="text-align: left"><a href="plugins/gis.html#node.gis_load_attrs"><code>gis_load_attrs</code></a></td><td style="text-align: left">Load node attributes from a GIS file</td></tr>
<tr><td style="text-align: left"><a href="plugins/gis.html"><code>gis</code></a></td><td style="text-align: left"><a href="plugins/gis.html#node.gis_load_network"><code>gis_load_network</code></a></td><td style="text-align: left">Load network from a GIS file</td></tr>
<tr><td style="text-align: left"><a href="plugins/gis.html"><code>gis</code></a></td><td style="text-align: left"><a href="plugins/gis.html#node.gis_save_connections"><code>gis_save_connections</code></a></td><td style="text-align: left">Save GIS file of the connections</td></tr>
<tr><td style="text-align: left"><a href="plugins/gis.html"><code>gis</code></a></td><td style="text-align: left"><a href="plugins/gis.html#node.gis_save_nodes"><code>gis_save_nodes</code></a></td><td style="text-align: left">Save GIS file of the nodes</td></tr>
<tr><td style="text-align: left"><a href="plugins/gnuplot.html"><code>gnuplot</code></a></td><td style="text-align: left"><a href="plugins/gnuplot.html#node.plot_timeseries"><code>plot_timeseries</code></a></td><td style="text-align: left">Generate a gnuplot file that plots the timeseries data in the network</td></tr>
<tr><td style="text-align: left"><a href="plugins/graphviz.html"><code>graphviz</code></a></td><td style="text-align: left"><a href="plugins/graphviz.html#node.save_graphviz"><code>save_graphviz</code></a></td><td style="text-align: left">Save the network as a graphviz file</td></tr>
<tr><td style="text-align: left"><a href="plugins/html.html"><code>html</code></a></td><td style="text-align: left"><a href="plugins/html.html#node.export_map"><code>export_map</code></a></td><td style="text-align: left">Exports the network as a HTML map</td></tr>
<tr><td style="text-align: left"><a href="plugins/nadi_pdf.html"><code>nadi_pdf</code></a></td><td style="text-align: left"><a href="plugins/nadi_pdf.html#node.typst_table"><code>typst_table</code></a></td><td style="text-align: left">Generate Typst code for given Table</td></tr>
<tr><td style="text-align: left"><a href="plugins/print_node.html"><code>print_node</code></a></td><td style="text-align: left"><a href="plugins/print_node.html#node.print_attr_csv"><code>print_attr_csv</code></a></td><td style="text-align: left">Print the given attributes in csv format with first column with node name</td></tr>
<tr><td style="text-align: left"><a href="plugins/render.html"><code>render</code></a></td><td style="text-align: left"><a href="plugins/render.html#node.render_nodes"><code>render_nodes</code></a></td><td style="text-align: left">Render each node of the network and combine to same variable</td></tr>
<tr><td style="text-align: left"><a href="plugins/render.html"><code>render</code></a></td><td style="text-align: left"><a href="plugins/render.html#node.render_template"><code>render_template</code></a></td><td style="text-align: left">Render a File template for the nodes in the whole network</td></tr>
<tr><td style="text-align: left"><a href="plugins/render.html"><code>render</code></a></td><td style="text-align: left"><a href="plugins/render.html#node.render"><code>render</code></a></td><td style="text-align: left">Render from network attributes</td></tr>
<tr><td style="text-align: left"><a href="plugins/table.html"><code>table</code></a></td><td style="text-align: left"><a href="plugins/table.html#node.save_csv"><code>save_csv</code></a></td><td style="text-align: left">Save CSV</td></tr>
<tr><td style="text-align: left"><a href="plugins/table.html"><code>table</code></a></td><td style="text-align: left"><a href="plugins/table.html#node.table_to_markdown"><code>table_to_markdown</code></a></td><td style="text-align: left">Render the Table as a rendered markdown</td></tr>
<tr><td style="text-align: left"><a href="plugins/timeseries.html"><code>timeseries</code></a></td><td style="text-align: left"><a href="plugins/timeseries.html#node.series_csv"><code>series_csv</code></a></td><td style="text-align: left">Write the given nodes to csv with given attributes and series</td></tr>
<tr><td style="text-align: left"><a href="plugins/timeseries.html"><code>timeseries</code></a></td><td style="text-align: left"><a href="plugins/timeseries.html#node.ts_print_csv"><code>ts_print_csv</code></a></td><td style="text-align: left">Save timeseries from all nodes into a single csv file</td></tr>
<tr><td style="text-align: left"><a href="plugins/visuals.html"><code>visuals</code></a></td><td style="text-align: left"><a href="plugins/visuals.html#node.set_nodesize_attrs"><code>set_nodesize_attrs</code></a></td><td style="text-align: left">Set the node size of the nodes based on the attribute value</td></tr>
<tr><td style="text-align: left"><a href="plugins/visuals.html"><code>visuals</code></a></td><td style="text-align: left"><a href="plugins/visuals.html#node.svg_save"><code>svg_save</code></a></td><td style="text-align: left">Exports the network as a svg</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="nadi-python-library"><a class="header" href="#nadi-python-library">Nadi Python Library</a></h1>
<p>This can be installed from <code>pypi</code> with <code>pip install nadi-py</code> command.</p>
<p>Then you can simply import and use it:</p>
<pre><code class="language-python">import nadi

net = nadi.Network.from_str("a -&gt; b")
print([n.NAME for n in net.nodes])
</code></pre>
<p>The functions are available inside the <code>nadi.functions</code> submodule.</p>
<pre><code class="language-python">import nadi
import nadi.functions as fn

net = nadi.Network.from_str("a -&gt; b")
fn.network.svg_save(net, "test.svg")
</code></pre>
<h1 id="combining-the-power-of-python-and-task-system"><a class="header" href="#combining-the-power-of-python-and-task-system">Combining the power of python and Task System</a></h1>
<p>You can combine the power of python with task system using the <code>command</code> function from Nadi. Basically, you write your logic that cannot be written in nadi in python, you can use <code>nadi-py</code> if you need to parse network files, load attributes or call any other nadi functions. And you can pass the results of the python script at the end by simply printing it to the standard output.</p>
<p>Future work is under consideration to have a tight couple between the python and nadi system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-with-task-system"><a class="header" href="#differences-with-task-system">Differences with Task System</a></h1>
<p>The difference from Task system is that now we use python syntax and the python functions. The environment from task system is no longer available, and the node functions are not automatically run in a loop.</p>
<p>We lose the advantages brought by the Domain Specific Programming Language, while gaining the flexibility and the well developed libraries of the python language.</p>
<p>Some examples showing how you’d have to write python codes from equivalent examples in the book are shown below.</p>
<h2 id="example-1-looping-through-the-nodes"><a class="header" href="#example-1-looping-through-the-nodes">Example 1: looping through the nodes</a></h2>
<pre><code class="language-task">network load_str("a -&gt; b\nc -&gt; b")
node(output._?) echo(env.render("{i} -&gt; {o}", i=node.INDEX, o=output.INDEX))
</code></pre>
<p>Results:</p>
<pre><code class="language-output">1 -&gt; 0
2 -&gt; 0
</code></pre>
<p>Equivalent Python:</p>
<pre><code class="language-python">import nadi

net = nadi.Network.from_str("a -&gt; b\nc -&gt; b")
for node in net.nodes:
    out = node.output()
	if out is None:
	    continue
    print(f"{node.INDEX} -&gt; {out.INDEX}")
</code></pre>
<p>Here the code for python is longer because it is general purpose and doesn’t have the syntax tailored for network analysis like with Nadi Task System.</p>
<h2 id="example-2-skip-execution-when-variable-is-absent"><a class="header" href="#example-2-skip-execution-when-variable-is-absent">Example 2: Skip execution when variable is absent</a></h2>
<p>If we had to check for an attribute, then it becomes even more complicated.</p>
<pre><code class="language-task">node(somevar?) somefunc(somevar)
</code></pre>
<pre><code class="language-python">import nadi
import nadi.functions as fn

net = nadi.Network.from_str("a -&gt; b\nc -&gt; b")
for node in net.nodes():
	try:
	    fn.node.somefun(node, node.somevar)
	except AttributeError:
	    continue
</code></pre>
<p>In case of multiple variables being used, the <code>AttributeError</code> might catch all of them, further fine tuning in python could make the code far longer than in nadi.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins-2"><a class="header" href="#plugins-2">Plugins</a></h1>
<p>Not only can you use <code>nadi-py</code> to write network based algorithms in python, you can also use it to write executable plugins that you can use to run analysis in python and feed it back to nadi system.</p>
<p>First thing to say about that is, you don’t need <code>nadi-py</code> for writing python plugins, as they are run as a normal python scripts.</p>
<h2 id="example-without-using-nadi-py"><a class="header" href="#example-without-using-nadi-py">Example without using nadi-py</a></h2>
<p>Here is an example task that calls python using the <code>command</code> function:</p>
<pre><code class="language-task">network load_file("scioto.network")

# load average streamflow from the csv file
# containing timeseries using python
node command("python area-and-streamflow.py {_NAME}")

# this just prints the attributes in csv format.
network print_attr_csv("INDEX", "area", "streamflow")
</code></pre>
<p>Here the <code>command</code> function takes a string template, renders it and runs it as a shell command for each node.</p>
<p>Our python script should have a way to read that node’s name that we passed to the python command.</p>
<pre><code class="language-python">import sys
import pandas as pd

try:
    station = sys.argv[1]
except IndexError:
    print("Give station")
    exit(1)

df = pd.read_csv(f"data/streamflow/{station}.csv", header=None)
sf = df.iloc[:, 4]
sf.index = pd.to_datetime(df.iloc[:, 2])
daily = sf.resample('1d').mean()
counts = daily.groupby(daily.index.year).count()
counts.index.name = "datetime"
daily.index.name = "datetime"
annual = daily.groupby(daily.index.year).mean().loc[counts &gt; 300]

print("nadi:var:sf_mean=", float(daily.mean()))

for year, flow in annual.items():
    print(f"nadi:var:sf_year_{year}={flow}")
</code></pre>
<p>Here the line <code>sys.argv[1]</code> reads the argument from command line (node’s name in this case). And reads the data for that node. The ouput is printed with prefix <code>nadi:var:</code> which tells nadi to load as <code>key=val</code> pair for that node.</p>
<h2 id="example-using-nadi-py"><a class="header" href="#example-using-nadi-py">Example using nadi-py</a></h2>
<p>The same example can be written using <code>nadi-py</code> so that the execution is very short (as it is being run as a network function instead of node function; <code>command</code> is a slow function as a new shell instance has to be created every time it is invoked).</p>
<p>Here we use the <code>command</code> network function and pass the network file as input. If your network has changed you can use <code>save_file</code> <code>network</code> function to save the network as a text file and then pass that instead.</p>
<pre><code class="language-task">network load_file("scioto.network")

# load average streamflow from the csv file
# containing timeseries using python
network command("python area-and-streamflow.py scioto.network")

# this just prints the attributes in csv format.
network print_attr_csv("INDEX", "area", "streamflow")
</code></pre>
<p>The corresponding python script now will look like this:</p>
<pre><code class="language-python">import sys
import pandas as pd
import nadi

try:
    network = sys.argv[1]
except IndexError:
    print("Give station")
    exit(1)

for node in nadi.Network(network).nodes():
	station = node.NAME
	df = pd.read_csv(f"data/streamflow/{station}.csv", header=None)
	sf = df.iloc[:, 4]
	sf.index = pd.to_datetime(df.iloc[:, 2])
	daily = sf.resample('1d').mean()
	counts = daily.groupby(daily.index.year).count()
	counts.index.name = "datetime"
	daily.index.name = "datetime"
	annual = daily.groupby(daily.index.year).mean().loc[counts &gt; 300]

	print(f"nadi:var:{station}:sf_mean=", float(daily.mean()))

	for year, flow in annual.items():
		print(f"nadi:var:{station}:sf_year_{year}={flow}")
</code></pre>
<p>Here we load the network using <code>nadi-py</code>, and then loop through the node, and pass the variables back to nadi through stdout. We have to pass the node names with the <code>nadi:var:</code> as this is being run for the whole network. Without the node name, it’ll take the <code>key=val</code> pair as network attribute.</p>
<p>This should allow users to have a lot of flexibility in using python to do complex analysis and get the results back into nadi directly. You can also save the results of the python script into a file, and check if the file exists before running the command from nadi to save the redundant computations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>TODO: add examples from papers’ case studies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executable-plugins-1"><a class="header" href="#executable-plugins-1">Executable Plugins</a></h1>
<p>Executable plugins are programs that can be called from terminal. The <a href="plugin-dev/../plugins/command.html#node.command">node <code>command</code> function</a>, <a href="plugin-dev/../plugins/command.html#network.command">network <code>command</code> function</a> and their families in the <a href="plugin-dev/../plugins/command.html"><code>command</code> plugin</a> have the capacity to run external programs through the command line.</p>
<p>The inputs to the program is given through the command line arguments, while the output of the programs are read through the standard output of the program. This can be used to call different/same commands for nodes with arguments dependent on their attributes.</p>
<p>And the output from the programs are taken by reading their stdout (standard output). Any lines starting from <code>nadi:var:</code> (prefix) is considered a communication attempt with Nadi. Currently, you can set attribute values by providing <code>key=val</code> pairs after the prefix. The node function will set it for current node, and network function will set it for the network. Furthermore, in network function, you can add one more section after prefix to set node attributes. For example, <code>nadi:var:node1:value=12</code> will set the <code>value</code> attribute to <code>12</code> in the node named <code>node1</code> in the current network.</p>
<p>The executable plugin or commands are language agnostic, as long as the command is available to run from the parent shell they will be run.</p>
<p>To learn how to write code in your language to parse command line arguments refer to the <a href="https://en.wikipedia.org/wiki/Command-line_argument_parsing">Wikipedia page on Command Line Arguments</a></p>
<p>The following section shows example programs written in python and R that can interact with nadi in this way.</p>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<p>Here is an example python script that can be called from nadi for each node. This script just reads a CSV file and passes the attributes to nadi, but more complicated programs can be written by the users.</p>
<p>First part is importing libraries and getting the arguments from nadi. The code below reads one string as a commandline argument and saves that into <code>station</code> variable.</p>
<pre><code class="language-python">import sys
import pandas as pd

try:
    station = sys.argv[1]
except IndexError:
    print("Give station")
    exit(1)
</code></pre>
<p>Then we can use any python logic with any libraries to do what we want. Here it reads the CSV and extracts values based on the station name. This is just an example, but you can load different csv files for each station and do a lot of analysis before sending those variables to nadi.</p>
<pre><code class="language-python"><span class="boring"> import sys
</span><span class="boring"> import pandas as pd
</span><span class="boring"> 
</span><span class="boring"> try:
</span><span class="boring">     station = sys.argv[1]
</span><span class="boring"> except IndexError:
</span><span class="boring">     print("Give station")
</span><span class="boring">     exit(1)
</span><span class="boring"> 
</span>df = pd.read_csv(f"data/streamflow/{station}.csv", header=None)
sf = df.iloc[:, 4]
sf.index = pd.to_datetime(df.iloc[:, 2])
sf = sf.resample('1d').mean()
</code></pre>
<p>Once we have our variables from analysis, we can simply print them with <code>nadi:var:</code> prefix so that nadi knows they are the variables it should read and load into each node.</p>
<pre><code class="language-python"><span class="boring"> import sys
</span><span class="boring"> import pandas as pd
</span><span class="boring"> 
</span><span class="boring"> try:
</span><span class="boring">     station = sys.argv[1]
</span><span class="boring"> except IndexError:
</span><span class="boring">     print("Give station")
</span><span class="boring">     exit(1)
</span><span class="boring"> 
</span><span class="boring"> df = pd.read_csv(f"data/streamflow/{station}.csv", header=None)
</span><span class="boring"> sf = df.iloc[:, 4]
</span><span class="boring"> sf.index = pd.to_datetime(df.iloc[:, 2])
</span><span class="boring"> sf = sf.resample('1d').mean()
</span>print("nadi:var:sf_mean=", float(sf.mean()))

for year, flow in sf.groupby(sf.index.year).mean().items():
    print(f"nadi:var:sf_year_{year}={flow}")
</code></pre>
<p>Now we can call this script from inside the nadi tasks system like the following, assuming the python file is saved as <code>streamflow.py</code>.</p>
<pre><code class="language-task">node command("python streamflow.py {_NAME}")
</code></pre>
<p>If you want to know what the template will be rendered as, use <code>render</code> function, and if you want to check whether it exists or not, you can use <code>exists</code> function.</p>
<h2 id="rscript"><a class="header" href="#rscript">RScript</a></h2>
<p>Similar to most programming languages R can also read command line arguments when ran with <code>RScript</code> command instead of <code>R</code>.</p>
<p>For example if you run the following script in a file called <code>test.r</code> and ran it with command <code>Rscript test.r some args 2</code>, you get the output of <code>[1] "some" "args" "2"</code></p>
<pre><code class="language-r">args &lt;- commandArgs(trailingOnly = TRUE)
print(args)
</code></pre>
<p>So you can use the same method like in python to pass arguments, do analysis and pass it back using the <code>cat</code> function in r as shown below. <code>cat</code> function avoids printing the <code>[1]</code> type indices to the stdout.</p>
<pre><code class="language-r">cat(sprintf("nadi:var:this_val=%d\n", 1200))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiled-plugins-1"><a class="header" href="#compiled-plugins-1">Compiled Plugins</a></h1>
<p>As it is not possible to forsee all the use cases in advance, the nadi
software can be easily extended (easy being an relative term) to
account for different use cases.</p>
<p>The program can load compiled shared libraries (<code>.dll</code> in windows,
<code>.so</code> in linux, and <code>.dylib</code> on mac). Since they are shared libraries
compiled into binaries, any programming languages can be used to
generate those. So far, the <code>nadi_core</code> library is available for
<code>Rust</code> only. Using that, plugins can be written and those functions
can be made available from the system.</p>
<p>Nadi core automatically loads:</p>
<ul>
<li>internal plugins if feature <code>functions</code> is used in <code>nadi_core</code> to compile it,</li>
<li>external plugins in the directories inside the <code>NADI_PLUGIN_DIRS</code> environmental variables. The plugins must be compiled using the same <code>nadi_core</code> version and must have the same internal ABI for data types.</li>
</ul>
<p>The syntax for functions in plugins are same for internal and external
plugins. While the way to register the plugin differ slightly.</p>
<p>The difference between the internal and external plugins are that, internal plugins are compiled with the <code>nadi_core</code> and come with the program, while external plugins are separately compiled and loaded through dynamic libraries.</p>
<p>The methods for writing the plugins are the same, except at the top level: to export plugins, you have to use [<code>nadi_core::nadi_plugin::nadi_plugin</code>] macro
for external plugins while
[<code>nadi_core::nadi_plugin::nadi_internal_plugin</code>] for internal ones.</p>
<p>In the next sections we will go in detail about how to write plugins and load them in nadi.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-plugins"><a class="header" href="#internal-plugins">Internal Plugins</a></h1>
<p>Internal plugins come with the nadi system. They are only modified between the different versions of Nadi.</p>
<p>The internal plugins provide core functionality of the Task system like data conversion, parsing network/attribute files, logical operations, template rendering, etc.</p>
<p>Future planned internal plugin functions can be found in <a href="https://github.com/Nadi-System/nadi-futures">nadi-futures</a> repository. Which in itself is an external plugin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-plugins"><a class="header" href="#external-plugins">External Plugins</a></h1>
<p>External plugins are plugins that are their own separate programs that compile to a shared library. The shared library has information about the name of the plugin, the functions that are available, as well as the bytecode required to run the functions.</p>
<p>You have to use the <code>nadi_core</code> library and the macros available there to make the plugins. Although it might be possible to write it without the macros (an example is provided), it is strongly discouraged. The example only serves as a way to demonstrate the inner working of the external plugins.</p>
<p>Some examples of external plugins are given in the <a href="https://github.com/Nadi-System/nadi-plugins-rust"><code>nadi-plugins-rust</code> repository</a>.</p>
<p>An example of a complex external plugin can be found in the <code>gis</code> plugin from <a href="https://github.com/Nadi-System/nadi-gis"><code>nadi-gis</code> repository</a>.</p>
<h2 id="steps-to-create-a-plugin"><a class="header" href="#steps-to-create-a-plugin">Steps to create a Plugin</a></h2>
<p><code>nadi</code> CLI tool has a function that can generate a plugin template. Simply run the <code>nadi</code> command with <code>--new-plugin</code> flag.</p>
<pre><code>nadi --new-plugin &lt;plugin-name&gt;
</code></pre>
<p>This will create a directory with plugin’s name with <code>Cargo.toml</code> and <code>src/lib.rs</code> with some sample codes for plugin functions. You can then edit them as per your need.</p>
<p>The generated files using <code>nadi --new-plugin sample</code> look something like this:</p>
<p>Cargo.toml:</p>
<pre><code class="language-toml">[package]
name = "sample"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

# make sure you use the same version of nadi_core, your nadi-system is in
[dependencies]
abi_stable = "0.11.3"
nadi_core = "0.7.0"
</code></pre>
<p>src/lib.rs:</p>
<pre><code class="language-rust">use nadi_core::nadi_plugin::nadi_plugin;

#[nadi_plugin]
mod sample {
    use nadi_core::prelude::*;

    /// The macros imported from nadi_plugin read the rust function you
    /// write and use that as a base to write more core internally that
    /// will be compiled into the shared libraries. This means it'll
    /// automatically get the argument types, documentation, mutability,
    /// etc. For more details on what they can do, refer to nadi book.
    use nadi_core::nadi_plugin::{env_func, network_func, node_func};

    /// Example Environment function for the plugin
    ///
    /// You can use markdown format to write detailed documentation for the
    /// function you write. This will be availble from nadi-help.
    #[env_func(pre = "Message: ")]
    fn echo(message: String, pre: String) -&gt; String {
        format!("{}{}", pre, message)
    }

    /// Example Node function for the plugin
    #[node_func]
    fn node_name(node: &amp;NodeInner) -&gt; String {
        node.name().to_string()
    }

    /// Example Network function for the plugin
    ///
    /// You can also write docstrings for the arguments, this syntax is not
    /// a valid rust syntax, but our macro will read those docstrings, saves
    /// it and then removes it so that rust does not get confused. This means
    /// You do not have to write separate documentation for functions.
    #[network_func]
    fn node_first_with_attr(
        net: &amp;Network,
        /// Name of the attribute to search
        attrname: String,
    ) -&gt; Option&lt;String&gt; {
        for node in net.nodes() {
            let node = node.lock();
            if node.attr_dot(&amp;attrname).is_ok() {
                return Some(node.name().to_string());
            }
        }
        None
    }
}</code></pre>
<p>The plugin can be compiled with the <code>cargo build</code> or <code>cargo build --release</code> command, it’ll generate the shared library in the <code>target/debug</code> or <code>target/release</code> folder. You can simply copy it to directory in <code>NADI_PLUGIN_DIRS</code> for it to be loaded.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Plugin functions are very close to normal rust functions, with extra syntax for the function arguments, and limited function argument and return types.</p>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<p>There are 3 function types:</p>
<ul>
<li>environment</li>
<li>node</li>
<li>network</li>
</ul>
<p>the macro used for each function type are availabel from <code>nadi_core::nadi_plugin</code>. All the macro take optional list of <code>key = value</code> pairs that can act like default arguments to the functions while called from the task system.</p>
<p>These macro will read the rust function and generate the necessary plugin code, function signature, documentation, and will even save the original code so that users can browse it through the <code>nadi-help</code>.</p>
<h2 id="function-arguments"><a class="header" href="#function-arguments">Function Arguments</a></h2>
<p>There are 5 types of function arugments, that are denoted by the following attributes</p>
<div class="table-wrapper"><table><thead><tr><th>macro attr</th><th>Type</th><th>Supported Types</th></tr></thead><tbody>
<tr><td></td><td>Node/Network</td><td><code>&amp;</code>/<code>&amp; mut</code> + <code>NodeInner</code>/<code>Network</code></td></tr>
<tr><td></td><td>Normal arguments</td><td><code>T: FromAttribute</code></td></tr>
<tr><td>#[relaxed]</td><td>Relaxed arguments</td><td><code>T: FromAttributeRelaxed</code></td></tr>
<tr><td>#[args]</td><td>Positional Arguments List</td><td><code>&amp;[Attribute]</code></td></tr>
<tr><td>#[kwargs]</td><td>Keyword Arguments AttrMap</td><td><code>&amp;AttrMap</code></td></tr>
</tbody></table>
</div>
<p>Users can not provide the argument <code>Node</code>/<code>Network</code> for node/network function as it is automatically provided based on the context.</p>
<p>Furthermore, there are required and optional arguments. And users can optionally omit the arguments that are of type <code>Option&lt;T&gt;</code>, or have default value in the macro (e.g. <code>safe = false</code> in the codes below).</p>
<p>For now, the function arguments except the <code>Node</code> or <code>Network</code> cannot be <code>mut</code>. But they can be reference of <code>T</code> if <code>T</code> satisfies the trait constraints, for example, instead of <code>Vec&lt;String&gt;</code>, it can be <code>&amp;[String]</code>. But because the function context is evaluated for each node/network, there is no optimization by using the references.</p>
<h2 id="return-types"><a class="header" href="#return-types">Return Types</a></h2>
<p>Function Return can be empty, an attribute value, or an error. When a function returns an error, the execution is halted. When it doesn’t return a value and an assignment is performed, it will error as well.</p>
<p>The return type of the function should implement <code>Into&lt;FunctinRet&gt;</code>, refer to the documentation for <a href="https://docs.rs/nadi_core/latest/nadi_core/functions/enum.FunctionRet.html"><code>nadi_core::functions::FunctionRet</code></a> to see what types implement it. You can also implement that for your own types.</p>
<p>You can simply use any type that satisfy the trait requirement mentioned above as a function return and the nadi macros will convert them automatically for you.</p>
<h2 id="verbosity"><a class="header" href="#verbosity">Verbosity</a></h2>
<p>In future versions the functions will also get a flag that will let them know how verbose the functions can be. This will also come with a way to pass progress and other information while the function is still running.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>Refer to the nadi_core, and other plugin repositories for sample codes for plugin functions as they are always up to date with the current version.</p>
<p>Here is an example containing render function that is available on all function types.</p>
<pre><code class="language-rust">    /// Render the template based on the given attributes
    ///
    /// For more details on the template system. Refer to the String
    /// Template section of the NADI book.
    #[env_func(safe = false)]
    fn render(
        /// String template to render
        template: &amp;Template,
        #[kwargs] keyval: &amp;AttrMap,
        /// if render fails keep it as it is instead of exiting
        safe: bool,
    ) -&gt; Result&lt;String, String&gt; {
        let text = if safe {
            keyval
                .render(template)
                .unwrap_or_else(|_| template.original().to_string())
        } else {
            keyval.render(template).map_err(|e| e.to_string())?
        };
        Ok(text)
    }</code></pre>
<pre><code class="language-rust">    /// Render the template based on the node attributes
    ///
    /// For more details on the template system. Refer to the String
    /// Template section of the NADI book.
    #[node_func(safe = false)]
    fn render(
        node: &amp;NodeInner,
        /// String template to render
        template: &amp;Template,
        /// if render fails keep it as it is instead of exiting
        safe: bool,
    ) -&gt; Result&lt;String, String&gt; {
        let text = if safe {
            node.render(template)
                .unwrap_or_else(|_| template.original().to_string())
        } else {
            node.render(template).map_err(|e| e.to_string())?
        };
        Ok(text)
    }</code></pre>
<pre><code class="language-rust">    /// Render from network attributes
    #[network_func(safe = false)]
    fn render(
        network: &amp;Network,
        /// Path to the template file
        template: &amp;Template,
        /// if render fails keep it as it is instead of exiting
        safe: bool,
    ) -&gt; Result&lt;String, String&gt; {
        let text = if safe {
            network
                .render(template)
                .unwrap_or_else(|_| template.original().to_string())
        } else {
            network.render(template).map_err(|e| e.to_string())?
        };
        Ok(text)
    }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-functions"><a class="header" href="#environment-functions">Environment Functions</a></h1>
<p>Environment functions are like any normal function on programming languages that take arguments and run code. In Nadi environment functions can be called from any scope. For example, if a node function and environement function share the same name, then in a node task node function is called, but in network task env function is called.</p>
<p>Environment functions are denoted in the plugins with <code>#[env_func]</code> macro. All the arguments this function takes need to be provided by user or through default values.</p>
<p>Here is an example of a environment function <code>and</code> in plugin <code>logic</code>.</p>
<pre><code class="language-rust">    /// Boolean and
    #[env_func]
    fn and(
        /// List of attributes that can be cast to bool
        #[args]
        conds: &amp;[Attribute],
    ) -&gt; bool {
        let mut ans = true;
        for c in conds {
            ans = ans &amp;&amp; bool::from_attr_relaxed(c).unwrap();
        }
        ans
    }</code></pre>
<p>This function can be called inside the task system in different context like follows:</p>
<pre><code class="language-task">env and(true, 12)
env.something = false
env and(something, true) == (something &amp; true)

network and(what?, and(true, true))
</code></pre>
<p>Results:</p>
<pre><code class="language-output">true
true
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-1"><a class="header" href="#node-functions-1">Node Functions</a></h1>
<p>Node functions are run for each node in the network (or a selected group of nodes). Hence, it takes the first argument as <code>&amp; NodeInner</code> or <code>&amp; mut NodeInner</code> depending on the purpose of the function. Immutable functions can be called from any place, while mutable functions can only be called once on the outermost layer on the task.</p>
<p>Other arguments and the return types for node functions are the same as the environement functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-1"><a class="header" href="#network-functions-1">Network Functions</a></h1>
<p>Network functions, like node functions take <code>&amp;Network</code> or <code>&amp; mut Network</code> as the first argument. It has the same restrictions as the env/node functions for the arguments and the return types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h1>
<h2 id="ohio-river-streamflow-routing-project"><a class="header" href="#ohio-river-streamflow-routing-project">Ohio River Streamflow Routing Project</a></h2>
<p>The Network for the flow routing is as follows:</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/ohio.network")
</span>network svg_save(label="{_NAME}", outfile = "./output/ohio.svg", height=1000)
</code></pre>
<p>Results:</p>
<center>  
<p><img src="../output/ohio.svg" alt="" /></p>
</center>  
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-tables"><a class="header" href="#making-tables">Making Tables</a></h1>
<pre><code class="language-table"><span class="boring">network load_file("./data/ohio.network")
</span><span class="boring">node load_attrs("./data/attrs/{_NAME}.toml")
</span><span class="boring">network clip()
</span><span class="boring"># ^Ind =&gt; =(+ (st+num 'INDEX) 1)
</span>&lt;Node ID =&gt; {_NAME}
&lt;Title =&gt; {_description:case(title):repl(Ky,KY):repl(In,IN):repl(Wv,WV):repl(Oh,OH)?}
&gt;Latitude =&gt; {lat:f(4)}
&gt;Longitude =&gt; {lon:f(4)}
</code></pre>
<p>Results:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Node ID</th><th style="text-align: left">Title</th><th style="text-align: right">Latitude</th><th style="text-align: right">Longitude</th></tr></thead><tbody>
<tr><td style="text-align: left">smithland</td><td style="text-align: left">OHio River at Smithland Dam Smithland KY</td><td style="text-align: right">37.1584</td><td style="text-align: right">-88.4262</td></tr>
<tr><td style="text-align: left">golconda</td><td style="text-align: left">OHio River at Dam 51 at Golconda, Il</td><td style="text-align: right">37.3578</td><td style="text-align: right">-88.4825</td></tr>
<tr><td style="text-align: left">old-shawneetown</td><td style="text-align: left">OHio River at Old Shawneetown, Il-KY</td><td style="text-align: right">37.6919</td><td style="text-align: right">-88.1333</td></tr>
<tr><td style="text-align: left">mountcarmel</td><td style="text-align: left">Wabash River at Mt. Carmel, Il</td><td style="text-align: right">38.3983</td><td style="text-align: right">-87.7564</td></tr>
<tr><td style="text-align: left">jt-myers</td><td style="text-align: left">OHio River at Uniontown Dam, KY</td><td style="text-align: right">37.7972</td><td style="text-align: right">-87.9983</td></tr>
<tr><td style="text-align: left">evansville</td><td style="text-align: left">OHio River at Evansville, IN</td><td style="text-align: right">37.9723</td><td style="text-align: right">-87.5764</td></tr>
<tr><td style="text-align: left">calhoun</td><td style="text-align: left">Green River at Lock 2 at Calhoun, KY</td><td style="text-align: right">37.5339</td><td style="text-align: right">-87.2639</td></tr>
<tr><td style="text-align: left">newburgh</td><td style="text-align: left">Newburgh</td><td style="text-align: right">37.9309</td><td style="text-align: right">-87.3722</td></tr>
<tr><td style="text-align: left">cannelton</td><td style="text-align: left">OHio River at Cannelton Dam at Cannelton, IN</td><td style="text-align: right">37.8995</td><td style="text-align: right">-86.7055</td></tr>
<tr><td style="text-align: left">shepherdsville</td><td style="text-align: left">Salt River at Shepherdsville, KY</td><td style="text-align: right">37.9851</td><td style="text-align: right">-85.7175</td></tr>
<tr><td style="text-align: left">mcalpine</td><td style="text-align: left">OHio River at Louisville, KY</td><td style="text-align: right">38.2803</td><td style="text-align: right">-85.7991</td></tr>
<tr><td style="text-align: left">lockport</td><td style="text-align: left">Kentucky River at Lock 2 at Lockport, KY</td><td style="text-align: right">38.4390</td><td style="text-align: right">-84.9633</td></tr>
<tr><td style="text-align: left">markland</td><td style="text-align: left">OHio River at Markland Dam Near Warsaw, KY</td><td style="text-align: right">38.7748</td><td style="text-align: right">-84.9644</td></tr>
<tr><td style="text-align: left">milford</td><td style="text-align: left">Little Miami River at Milford OH</td><td style="text-align: right">39.1714</td><td style="text-align: right">-84.2980</td></tr>
<tr><td style="text-align: left">catawba</td><td style="text-align: left">Licking River at Catawba, KY</td><td style="text-align: right">38.7103</td><td style="text-align: right">-84.3108</td></tr>
<tr><td style="text-align: left">hamilton</td><td style="text-align: left">Great Miami River at Hamilton OH</td><td style="text-align: right">39.3912</td><td style="text-align: right">-84.5722</td></tr>
<tr><td style="text-align: left">perintown</td><td style="text-align: left">East Fork Little Miami River at Perintown OH</td><td style="text-align: right">39.1370</td><td style="text-align: right">-84.2380</td></tr>
<tr><td style="text-align: left">brookville</td><td style="text-align: left">Whitewater River at Brookville, IN</td><td style="text-align: right">39.4075</td><td style="text-align: right">-85.0129</td></tr>
<tr><td style="text-align: left">meldahl</td><td style="text-align: left">Meldahl</td><td style="text-align: right">38.7972</td><td style="text-align: right">-84.1705</td></tr>
<tr><td style="text-align: left">higby</td><td style="text-align: left">Scioto River at Higby OH</td><td style="text-align: right">39.2123</td><td style="text-align: right">-82.8638</td></tr>
<tr><td style="text-align: left">greenup</td><td style="text-align: left">Greenup</td><td style="text-align: right">38.6468</td><td style="text-align: right">-82.8608</td></tr>
<tr><td style="text-align: left">grayson</td><td style="text-align: left">Little Sandy River at Grayson, KY</td><td style="text-align: right">38.3301</td><td style="text-align: right">-82.9393</td></tr>
<tr><td style="text-align: left">ashland</td><td style="text-align: left">OHio River at Ashland, KY</td><td style="text-align: right">38.4812</td><td style="text-align: right">-82.6365</td></tr>
<tr><td style="text-align: left">branchland</td><td style="text-align: left">Guyandotte River at Branchland, WV</td><td style="text-align: right">38.2209</td><td style="text-align: right">-82.2026</td></tr>
<tr><td style="text-align: left">rc-byrd</td><td style="text-align: left">Rc-Byrd</td><td style="text-align: right">38.6816</td><td style="text-align: right">-82.1883</td></tr>
<tr><td style="text-align: left">charleston</td><td style="text-align: left">Kanawha River at Charleston, WV</td><td style="text-align: right">38.3715</td><td style="text-align: right">-81.7021</td></tr>
<tr><td style="text-align: left">racine</td><td style="text-align: left">OHio River at Racine Dam, WV</td><td style="text-align: right">38.9167</td><td style="text-align: right">-81.9121</td></tr>
<tr><td style="text-align: left">belleville</td><td style="text-align: left">OHio River at Belleville Dam, WV</td><td style="text-align: right">39.1190</td><td style="text-align: right">-81.7424</td></tr>
<tr><td style="text-align: left">mcconnelsville</td><td style="text-align: left">Muskingum River at McConnelsville OH</td><td style="text-align: right">39.6451</td><td style="text-align: right">-81.8499</td></tr>
<tr><td style="text-align: left">athens</td><td style="text-align: left">Hocking River at Athens OH</td><td style="text-align: right">39.3290</td><td style="text-align: right">-82.0876</td></tr>
<tr><td style="text-align: left">elizabeth</td><td style="text-align: left">Little Kanawha River at Palestine, WV</td><td style="text-align: right">39.0590</td><td style="text-align: right">-81.3896</td></tr>
<tr><td style="text-align: left">willow-island</td><td style="text-align: left">Willow-Island</td><td style="text-align: right">39.3605</td><td style="text-align: right">-81.3204</td></tr>
<tr><td style="text-align: left">hannibal</td><td style="text-align: left">Hannibal</td><td style="text-align: right">39.6671</td><td style="text-align: right">-80.8653</td></tr>
<tr><td style="text-align: left">pike-island</td><td style="text-align: left">OHio River at Martins Ferry, OH</td><td style="text-align: right">40.1051</td><td style="text-align: right">-80.7084</td></tr>
<tr><td style="text-align: left">new-cumberland</td><td style="text-align: left">New-Cumberland</td><td style="text-align: right">40.5277</td><td style="text-align: right">-80.6276</td></tr>
<tr><td style="text-align: left">montgomery</td><td style="text-align: left">Montgomery</td><td style="text-align: right">40.6486</td><td style="text-align: right">-80.3855</td></tr>
<tr><td style="text-align: left">beaverfalls</td><td style="text-align: left">Beaver River at Beaver Falls, PA</td><td style="text-align: right">40.7634</td><td style="text-align: right">-80.3151</td></tr>
<tr><td style="text-align: left">dashields</td><td style="text-align: left">OHio River at Sewickley, PA</td><td style="text-align: right">40.5492</td><td style="text-align: right">-80.2056</td></tr>
<tr><td style="text-align: left">emsworth</td><td style="text-align: left">Emsworth</td><td style="text-align: right">40.5043</td><td style="text-align: right">-80.0889</td></tr>
<tr><td style="text-align: left">natrona</td><td style="text-align: left">Allegheny River at Natrona, PA</td><td style="text-align: right">40.6153</td><td style="text-align: right">-79.7184</td></tr>
<tr><td style="text-align: left">elizabeth2</td><td style="text-align: left">Monongahela River at Elizabeth, PA</td><td style="text-align: right">40.2623</td><td style="text-align: right">-79.9012</td></tr>
<tr><td style="text-align: left">sutersville</td><td style="text-align: left">Youghiogheny River at Sutersville, PA</td><td style="text-align: right">40.2402</td><td style="text-align: right">-79.8067</td></tr>
</tbody></table>
</div>
<p>Nadi style table with network information:</p>
<pre><code class="language-table"><span class="boring">network load_file("./data/ohio.network")
</span><span class="boring">node load_attrs("./data/attrs/{_NAME}.toml")
</span><span class="boring">network clip()
</span><span class="boring">network echo("../output/ohio-table.svg")
</span><span class="boring"># ^Ind =&gt; =(+ (st+num 'INDEX) 1)
</span>&lt;Node ID =&gt; {_NAME}
&lt;Title =&gt; {_description:case(title):repl(Ky,KY):repl(In,IN):repl(Wv,WV):repl(Oh,OH)?}
&gt;Latitude =&gt; {lat:f(4)}
&gt;Longitude =&gt; {lon:f(4)}
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">network function: "table_to_svg" not found
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-reports"><a class="header" href="#generating-reports">Generating Reports</a></h1>
<p>So we write this template:</p>
<pre><code class="language-stp-md">
## Ohio River Routing Project

&lt;!-- ---8&lt;---:[smithland]: --&gt;
Our basin Outlet is at {_description:case(title):repl(Ky,KY)} with the total basin area {basin_area:f(1)} acre-ft.
&lt;!-- ---8&lt;--- --&gt;

The lower part of the Ohio basin are specifically important to us. Those are:
| ID      | Basin Area   | Length to Outlet |
|---------|-------------:|-----------------:|
&lt;!-- ---8&lt;---:[greenup -&gt; smithland]: --&gt;
| {_NAME} | {basin_area:f(1)} | {length:f(2)}  |
&lt;!-- ---8&lt;--- --&gt;


We used 4 locks and dams in the ohio river as representative locks and dams as below:

&lt;!-- ---8&lt;---:["willow-island",racine,markland,smithland]: --&gt;
- {_NAME:repl(-, ):case(title)?}

  ![](../data/{_NAME}.svg)
&lt;!-- ---8&lt;--- --&gt;
</code></pre>
<p>Which makes the table only for the main-stem ohio:</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/ohio.network")
</span><span class="boring">node load_attrs("./data/attrs/{_NAME}.toml")
</span><span class="boring">network clip()
</span>network render("./data/ohio-report.template")
</code></pre>
<p>Results:<br />
“./data/ohio-report.template”</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysing-timeseries"><a class="header" href="#analysing-timeseries">Analysing Timeseries</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="looking-at-data-gaps"><a class="header" href="#looking-at-data-gaps">Looking at Data Gaps</a></h1>
<p>Couting the gaps in a csv data with all the nodes is easy. Let’s look
at the top 5 nodes with data gaps.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/ohio.network")
</span><span class="boring">network clip()
</span>network csv_count_na(
	"./data/ts/observed.csv",
	sort=true,
	head = 5
)
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">----8&lt;----

network function: "csv_count_na" not found
</code></pre>
<p>Running it for two timeseries, and comparing them base don network
information. We can see the downstream part have more missing data on
natural timeseries.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/ohio.network")
</span>network csv_count_na("./data/ts/observed.csv", outattr = "observed_missing")
network csv_count_na("./data/ts/natural.csv", outattr = "natural_missing")
<span class="boring">network table_to_svg(
</span><span class="boring">	template="
</span><span class="boring">&lt;Node=&gt; {_NAME}
</span><span class="boring">&gt;Observed =&gt; {observed_missing}
</span><span class="boring">&gt;Natural =&gt; {natural_missing}
</span><span class="boring">",
</span><span class="boring">	outfile="./output/natural-gaps.svg"
</span><span class="boring">)
</span><span class="boring">network clip()
</span><span class="boring">network echo("
</span><span class="boring">&lt;center&gt;
</span><span class="boring">Number of Missing Days in Timeseries Data
</span><span class="boring">
</span><span class="boring"> ![](../output/natural-gaps.svg)
</span><span class="boring">&lt;center&gt;
</span><span class="boring">")
</span></code></pre>
<p>*Error*:</p>
<pre><code class="language-error">network function: "csv_count_na" not found
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visualizing-data-gaps"><a class="header" href="#visualizing-data-gaps">Visualizing Data Gaps</a></h1>
<p>To look at the temporal distribution of the gaps, we can use this function.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/ohio.network")
</span>network csv_count_na("./data/ts/natural.csv", outattr = "nat_na")
network csv_data_blocks_svg(
	csvfile="./data/ts/natural.csv",
	outfile="./output/natural-blocks.svg",
	label="{_NAME} ({=(/ (st+num 'nat_na) 365.0):f(1)} yr)"
)
<span class="boring">network clip()
</span><span class="boring">network echo("../output/natural-blocks.svg")
</span></code></pre>
<p>*Error*:</p>
<pre><code class="language-error">network function: "csv_count_na" not found
</code></pre>
<pre><code class="language-task"><span class="boring">network load_file("./data/ohio.network")
</span>network csv_count_na("./data/ts/observed.csv", outattr = "obs_na")
network csv_data_blocks_svg(
	csvfile="./data/ts/observed.csv",
	outfile="./output/observed-blocks.svg",
	label="{_NAME} ({obs_na})"
)
<span class="boring">network clip()
</span><span class="boring">network echo("../output/observed-blocks.svg")
</span></code></pre>
<p>*Error*:</p>
<pre><code class="language-error">network function: "csv_count_na" not found
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-plugins-1"><a class="header" href="#internal-plugins-1">Internal Plugins</a></h1>
<p>There are some plugins that are provided with the <code>nadi_core</code>
library. They are part of the library, so users can directly use them.</p>
<p>For example in the following tasks file, the functions that are
highlighted are functions available from the core plugins. Other
functions need to be loaded from plugins.</p>
<pre><code class="language-task"># sample .tasks file which is like a script with functions
node&lt;inputsfirst&gt; print_attrs("uniqueID")
node show_node()
network save_graphviz("/tmp/test.gv")
node&lt;inputsfirst&gt;.cum_val = node.val + sum(inputs.cum_val);

node[WV04113,WV04112,WV04112] print_attr_toml("testattr2")
node render("{NAME} {uniqueID} {_Dam_Height_(Ft)?}")
node list_attr("; ")
# some functions can take variable number of inputs
network calc_attr_errors(
    "Dam_Height_(Ft)",
    "Hydraulic_Height_(Ft)",
    "rmse", "nse", "abserr"
)
node sum_safe("Latitude")
node&lt;inputsfirst&gt; render("Hi {SUM_ATTR}")
# multiple line for function arguments
network save_table(
	"test.table",
	"/tmp/test.tex",
	true,
	radius=0.2,
	start = 2012-19-20,
	end = 2012-19-23 12:04
	)
node.testattr = 2
node set_attrs_render(testattr2 = "{testattr:calc(+2)}")
node[WV04112] render("{testattr} {testattr2}")

# here we use a complicated template that can do basic logic handling
node set_attrs_render(
    testattr2 = "=(if (and (st+has 'Latitude) (&gt; (st+num 'Latitude) 39)) 'true 'false)"
)
# same thing can be done if you need more flexibility in variable names
node load_toml_string(
    "testattr2 = =(if (and (st+has 'Latitude) (&gt; (st+num 'Latitude) 39)) 'true 'false)"
)
# selecting a list of nodes to run a function
node[
	# comment here?
    WV04113,
    WV04112
] print_attr_toml("testattr2")
# selecting a path
node[WV04112 -&gt; WV04113] render("=(&gt; 2 3)")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env-functions-1"><a class="header" href="#env-functions-1">Env Functions</a></h1>
<h2 id="env.strmap"><a class="header" href="#env.strmap">strmap</a></h2>
<pre><code class="language-sig">env attributes.strmap(
    attr: '&amp; str',
    attrmap: '&amp; AttrMap',
    default: 'Option &lt; Attribute &gt;'
)
</code></pre>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; Value to transform the attribute</li>
<li><code>attrmap: '&amp; AttrMap'</code> =&gt; Dictionary of key=value to map the data to</li>
<li><code>default: 'Option &lt; Attribute &gt;'</code> =&gt; Default value if key not found in <code>attrmap</code></li>
</ul>
<p>map values from the attribute based on the given table</p>
<pre><code class="language-task">env.val = strmap("Joe", {Dave = 2, Joe = 20});
env assert_eq(val, 20)
env.val2 = strmap("Joe", {Dave=2}, default = 12);
env assert_eq(val2, 12)
</code></pre>
<h2 id="env.parse_attr"><a class="header" href="#env.parse_attr">parse_attr</a></h2>
<pre><code class="language-sig">env attributes.parse_attr(toml: '&amp; str')
</code></pre>
<h3 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h3>
<ul>
<li><code>toml: '&amp; str'</code> =&gt; String to parse into attribute</li>
</ul>
<p>Parse attribute from string</p>
<pre><code class="language-task">env assert_eq(parse_attr("true"), true)
env assert_eq(parse_attr("123"), 123)
env assert_eq(parse_attr("12.34"), 12.34)
env assert_eq(parse_attr("\"my value\""), "my value")
env assert_eq(parse_attr("1234-12-12"), 1234-12-12)
</code></pre>
<h2 id="env.parse_attrmap"><a class="header" href="#env.parse_attrmap">parse_attrmap</a></h2>
<pre><code class="language-sig">env attributes.parse_attrmap(toml: 'String')
</code></pre>
<h3 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h3>
<ul>
<li><code>toml: 'String'</code> =&gt; String to parse into attribute</li>
</ul>
<p>Parse attribute from string</p>
<pre><code class="language-task">env assert_eq(parse_attrmap("y = true"), {y = true})
env assert_eq(parse_attrmap(
"x = [1234-12-12, true]"),
{x = [1234-12-12, true]}
)
</code></pre>
<h2 id="env.get"><a class="header" href="#env.get">get</a></h2>
<pre><code class="language-sig">env attributes.get(
    parent: 'Attribute',
    index: 'Attribute',
    default: 'Option &lt; Attribute &gt;'
)
</code></pre>
<h3 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h3>
<ul>
<li><code>parent: 'Attribute'</code> =&gt; Array or AttrMap Attribute to index</li>
<li><code>index: 'Attribute'</code> =&gt; Index value (Integer for Array, String for AttrMap)</li>
<li><code>default: 'Option &lt; Attribute &gt;'</code> =&gt; Default value if the index is not present</li>
</ul>
<p>get the choosen attribute from Array or AttrMap</p>
<pre><code class="language-task">env.some_ar = ["this", 12, true];
env.some_am = {x = "this", y = [12, true]};
env assert_eq(get(some_ar, 0), "this")
env assert_eq(get(some_ar, 2), true)
env assert_eq(get(some_am, "x"), "this")
env assert_eq(get(some_am, "y"), [12, true])
</code></pre>
<h2 id="env.powi"><a class="header" href="#env.powi">powi</a></h2>
<pre><code class="language-sig">env attributes.powi(value: 'f64', power: 'i64')
</code></pre>
<h3 id="arguments-4"><a class="header" href="#arguments-4">Arguments</a></h3>
<ul>
<li><code>value: 'f64'</code> =&gt; base value</li>
<li><code>power: 'i64'</code> =&gt;</li>
</ul>
<p>Integer power</p>
<pre><code class="language-task">env assert_eq(powi(10.0, 2), 100.0)
</code></pre>
<h2 id="env.powf"><a class="header" href="#env.powf">powf</a></h2>
<pre><code class="language-sig">env attributes.powf(value: 'f64', power: 'f64')
</code></pre>
<h3 id="arguments-5"><a class="header" href="#arguments-5">Arguments</a></h3>
<ul>
<li><code>value: 'f64'</code> =&gt; base value</li>
<li><code>power: 'f64'</code> =&gt;</li>
</ul>
<p>Float power</p>
<pre><code class="language-task">env assert_eq(powf(100.0, 0.5), 10.0)
</code></pre>
<h2 id="env.exp"><a class="header" href="#env.exp">exp</a></h2>
<pre><code class="language-sig">env attributes.exp(value: 'f64')
</code></pre>
<h3 id="arguments-6"><a class="header" href="#arguments-6">Arguments</a></h3>
<ul>
<li><code>value: 'f64'</code> =&gt;</li>
</ul>
<p>Exponential</p>
<pre><code class="language-task">env assert_eq(log(exp(5.0)), 5.0)
</code></pre>
<h2 id="env.sqrt"><a class="header" href="#env.sqrt">sqrt</a></h2>
<pre><code class="language-sig">env attributes.sqrt(value: 'f64')
</code></pre>
<h3 id="arguments-7"><a class="header" href="#arguments-7">Arguments</a></h3>
<ul>
<li><code>value: 'f64'</code> =&gt;</li>
</ul>
<p>Square Root</p>
<pre><code class="language-task">env assert_eq(sqrt(25.0), 5.0)
</code></pre>
<h2 id="env.log"><a class="header" href="#env.log">log</a></h2>
<pre><code class="language-sig">env attributes.log(value: 'f64', base: 'Option &lt; f64 &gt;')
</code></pre>
<h3 id="arguments-8"><a class="header" href="#arguments-8">Arguments</a></h3>
<ul>
<li><code>value: 'f64'</code> =&gt;</li>
<li><code>base: 'Option &lt; f64 &gt;'</code> =&gt;</li>
</ul>
<p>Logarithm of a value, natural if base not given</p>
<pre><code class="language-task">env assert_eq(log(exp(2.0)), 2.0)
env assert_eq(log(2.0, 2.0), 1.0)
</code></pre>
<h2 id="env.float_div"><a class="header" href="#env.float_div">float_div</a></h2>
<pre><code class="language-sig">env attributes.float_div(value1: 'f64', value2: 'f64')
</code></pre>
<h3 id="arguments-9"><a class="header" href="#arguments-9">Arguments</a></h3>
<ul>
<li><code>value1: 'f64'</code> =&gt; numerator</li>
<li><code>value2: 'f64'</code> =&gt; denominator</li>
</ul>
<p>Float Division (same as / operator)</p>
<pre><code class="language-task">env assert_eq(float_div(10.0, 2), 10.0 / 2)
</code></pre>
<h2 id="env.float_mult"><a class="header" href="#env.float_mult">float_mult</a></h2>
<pre><code class="language-sig">env attributes.float_mult(value1: 'f64', value2: 'f64')
</code></pre>
<h3 id="arguments-10"><a class="header" href="#arguments-10">Arguments</a></h3>
<ul>
<li><code>value1: 'f64'</code> =&gt; numerator</li>
<li><code>value2: 'f64'</code> =&gt; denominator</li>
</ul>
<p>Float Multiplication (same as * operator)</p>
<pre><code class="language-task">env assert_eq(float_mult(5.0, 2), 5.0 * 2)
</code></pre>
<h1 id="node-functions-2"><a class="header" href="#node-functions-2">Node Functions</a></h1>
<h2 id="node.load_attrs"><a class="header" href="#node.load_attrs">load_attrs</a></h2>
<pre><code class="language-sig">node attributes.load_attrs(filename: 'PathBuf')
</code></pre>
<h3 id="arguments-11"><a class="header" href="#arguments-11">Arguments</a></h3>
<ul>
<li><code>filename: 'PathBuf'</code> =&gt; Template for the filename to load node attributes from</li>
</ul>
<p>Loads attrs from file for all nodes based on the given template</p>
<h3 id="arguments-12"><a class="header" href="#arguments-12">Arguments</a></h3>
<ul>
<li><code>filename</code>: Template for the filename to load node attributes from</li>
<li><code>verbose</code>: print verbose message</li>
</ul>
<p>The template will be rendered for each node, and that filename from the
rendered template will be used to load the attributes.</p>
<h3 id="errors"><a class="header" href="#errors">Errors</a></h3>
<p>The function will error out in following conditions:</p>
<ul>
<li>Template for filename is not given,</li>
<li>The template couldn’t be rendered,</li>
<li>There was error loading attributes from the file.</li>
</ul>
<h2 id="node.print_all_attrs"><a class="header" href="#node.print_all_attrs">print_all_attrs</a></h2>
<pre><code class="language-sig">node attributes.print_all_attrs()
</code></pre>
<h3 id="arguments-13"><a class="header" href="#arguments-13">Arguments</a></h3>
<p>Print all attrs in a node</p>
<p>No arguments and no errors, it’ll just print all the attributes in a node with
<code>node::attr=val</code> format, where,</p>
<ul>
<li>node is node name</li>
<li>attr is attribute name</li>
<li>val is attribute value (string representation)</li>
</ul>
<h2 id="node.print_attrs"><a class="header" href="#node.print_attrs">print_attrs</a></h2>
<pre><code class="language-sig">node attributes.print_attrs(*attrs, name: 'bool' = false)
</code></pre>
<h3 id="arguments-14"><a class="header" href="#arguments-14">Arguments</a></h3>
<ul>
<li><code>*attrs</code> =&gt;</li>
<li><code>name: 'bool' = false</code> =&gt;</li>
</ul>
<p>Print the given node attributes if present</p>
<h3 id="arguments-15"><a class="header" href="#arguments-15">Arguments</a></h3>
<ul>
<li>attrs,… : list of attributes to print</li>
<li>name: Bool for whether to show the node name or not</li>
</ul>
<h3 id="error"><a class="header" href="#error">Error</a></h3>
<p>The function will error if</p>
<ul>
<li>list of arguments are not <code>String</code></li>
<li>the <code>name</code> argument is not Boolean</li>
</ul>
<p>The attributes will be printed in <code>key=val</code> format.</p>
<h2 id="node.set_attrs"><a class="header" href="#node.set_attrs">set_attrs</a></h2>
<pre><code class="language-sig">node attributes.set_attrs(**attrs)
</code></pre>
<h3 id="arguments-16"><a class="header" href="#arguments-16">Arguments</a></h3>
<ul>
<li><code>**attrs</code> =&gt; Key value pairs of the attributes to set</li>
</ul>
<p>Set node attributes</p>
<p>Use this function to set the node attributes of all nodes, or
a select few nodes using the node selection methods (path or
list of nodes)</p>
<h3 id="error-1"><a class="header" href="#error-1">Error</a></h3>
<p>The function should not error.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Following will set the attribute <code>a2d</code> to <code>true</code> for all nodes
from <code>A</code> to <code>D</code></p>
<pre><code class="language-task">network load_str("A -&gt; B\n B -&gt; D");
node[A -&gt; D] set_attrs(a2d = true)
</code></pre>
<p>This is equivalent to the following:</p>
<pre><code class="language-task">node[A-&gt;D].a2d = true;
</code></pre>
<h2 id="node.get_attr"><a class="header" href="#node.get_attr">get_attr</a></h2>
<pre><code class="language-sig">node attributes.get_attr(attr: '&amp; str', default: 'Option &lt; Attribute &gt;')
</code></pre>
<h3 id="arguments-17"><a class="header" href="#arguments-17">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; Name of the attribute to get</li>
<li><code>default: 'Option &lt; Attribute &gt;'</code> =&gt; Default value if the attribute is not found</li>
</ul>
<p>Retrive attribute</p>
<pre><code class="language-task">network load_str("A -&gt; B\n B -&gt; D");
node assert_eq(get_attr("NAME"), NAME);
</code></pre>
<h2 id="node.has_attr"><a class="header" href="#node.has_attr">has_attr</a></h2>
<pre><code class="language-sig">node attributes.has_attr(attr: '&amp; str')
</code></pre>
<h3 id="arguments-18"><a class="header" href="#arguments-18">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; Name of the attribute to check</li>
</ul>
<p>Check if the attribute is present</p>
<pre><code class="language-task">network load_str("A -&gt; B\n B -&gt; D");
node.x = 90;
node assert(has_attr("x"))
node assert(!has_attr("y"))
</code></pre>
<h2 id="node.first_attr"><a class="header" href="#node.first_attr">first_attr</a></h2>
<pre><code class="language-sig">node attributes.first_attr(attrs: '&amp; [String]', default: 'Option &lt; Attribute &gt;')
</code></pre>
<h3 id="arguments-19"><a class="header" href="#arguments-19">Arguments</a></h3>
<ul>
<li><code>attrs: '&amp; [String]'</code> =&gt; attribute names</li>
<li><code>default: 'Option &lt; Attribute &gt;'</code> =&gt; Default value if not found</li>
</ul>
<p>Return the first Attribute that exists</p>
<p>This is useful when you have a bunch of attributes that might
be equivalent but are using different names. Normally due to
them being combined from different datasets.</p>
<pre><code class="language-task">network load_str("A -&gt; B\n B -&gt; D");
node.x = 90;
node assert_eq(first_attr(["y", "x"]), 90)
node assert_eq(first_attr(["x", "NAME"]), 90)
</code></pre>
<h2 id="node.set_attrs_ifelse"><a class="header" href="#node.set_attrs_ifelse">set_attrs_ifelse</a></h2>
<pre><code class="language-sig">node attributes.set_attrs_ifelse(cond: 'bool', **values)
</code></pre>
<h3 id="arguments-20"><a class="header" href="#arguments-20">Arguments</a></h3>
<ul>
<li><code>cond: 'bool'</code> =&gt; Condition to check</li>
<li><code>**values</code> =&gt; key = [val1, val2] where key is set as first if <code>cond</code> is true else second</li>
</ul>
<p>if else condition with multiple attributes</p>
<pre><code class="language-task">network load_str("a -&gt; b");
env.some_condition = true;
node set_attrs_ifelse(
env.some_condition,
val1 = [1, 2],
val2 = ["a", "b"]
);
env assert_eq(nodes.val1, [1, 1])
env assert_eq(nodes.val2, ["a", "a"])
</code></pre>
<p>This is equivalent to using the if-else expression directly,</p>
<pre><code class="language-task">node.val1 = if (env.some_condition) {1} else {2};
env assert_eq(nodes.val1, [1, 1])
</code></pre>
<p>Furthermore if-else expression will give a lot more
flexibility than this function in normal use cases. But this
function is useful when you have to do something in a batch.</p>
<h2 id="node.set_attrs_render"><a class="header" href="#node.set_attrs_render">set_attrs_render</a></h2>
<pre><code class="language-sig">node attributes.set_attrs_render(**kwargs)
</code></pre>
<h3 id="arguments-21"><a class="header" href="#arguments-21">Arguments</a></h3>
<ul>
<li><code>**kwargs</code> =&gt; key value pair of attribute to set and the Template to render</li>
</ul>
<p>Set node attributes based on string templates</p>
<p>This renders the template for each node, then it sets the
values from the rendered results.</p>
<pre><code class="language-task">network load_str("a -&gt; b");
node set_attrs_render(val1 = "Node: {_NAME}");
node[a] assert_eq(val1, "Node: a")
</code></pre>
<h2 id="node.load_toml_render"><a class="header" href="#node.load_toml_render">load_toml_render</a></h2>
<pre><code class="language-sig">node attributes.load_toml_render(toml: '&amp; Template', echo: 'bool' = false)
</code></pre>
<h3 id="arguments-22"><a class="header" href="#arguments-22">Arguments</a></h3>
<ul>
<li><code>toml: '&amp; Template'</code> =&gt; String template to render and load as toml string</li>
<li><code>echo: 'bool' = false</code> =&gt; Print the rendered toml or not</li>
</ul>
<p>Set node attributes by loading a toml from rendered template</p>
<p>This function will render a string, and loads it as a toml
string. This is useful when you need to make attributes based
on some other variables that you can combine using the string
template system.</p>
<p>In most cases it is better to use the string manipulation
functions and other environmental functions to get new
attribute values to set.</p>
<pre><code class="language-task">network load_str("a -&gt; b");
node load_toml_render("label = \\\"Node: {_NAME}\\\"")
node assert_eq(label, render("Node: {_NAME}"))
</code></pre>
<h1 id="network-functions-2"><a class="header" href="#network-functions-2">Network Functions</a></h1>
<h2 id="network.set_attrs"><a class="header" href="#network.set_attrs">set_attrs</a></h2>
<pre><code class="language-sig">network attributes.set_attrs(**attrs)
</code></pre>
<h3 id="arguments-23"><a class="header" href="#arguments-23">Arguments</a></h3>
<ul>
<li><code>**attrs</code> =&gt; key value pair of attributes to set</li>
</ul>
<p>Set network attributes</p>
<h3 id="arguments-24"><a class="header" href="#arguments-24">Arguments</a></h3>
<ul>
<li><code>key=value</code> - Kwargs of attr = value</li>
</ul>
<pre><code class="language-task">network set_attrs(val = 23.4)
network assert_eq(val, 23.4)
</code></pre>
<h2 id="network.set_attrs_render"><a class="header" href="#network.set_attrs_render">set_attrs_render</a></h2>
<pre><code class="language-sig">network attributes.set_attrs_render(**kwargs)
</code></pre>
<h3 id="arguments-25"><a class="header" href="#arguments-25">Arguments</a></h3>
<ul>
<li><code>**kwargs</code> =&gt; Kwargs of attr = String template to render</li>
</ul>
<p>Set network attributes based on string templates</p>
<p>It will set the attribute as a String</p>
<pre><code class="language-task">network.val = 23.4
network set_attrs_render(val2 = "{val}05")
network assert_eq(val2, "23.405")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-3"><a class="header" href="#node-functions-3">Node Functions</a></h1>
<h2 id="node.command"><a class="header" href="#node.command">command</a></h2>
<pre><code class="language-sig">node command.command(
    cmd: '&amp; Template',
    verbose: 'bool' = true,
    echo: 'bool' = false
)
</code></pre>
<h3 id="arguments-26"><a class="header" href="#arguments-26">Arguments</a></h3>
<ul>
<li><code>cmd: '&amp; Template'</code> =&gt; String Command template to run</li>
<li><code>verbose: 'bool' = true</code> =&gt; Show the rendered version of command, and other messages</li>
<li><code>echo: 'bool' = false</code> =&gt; Echo the stdout from the command</li>
</ul>
<p>Run the given template as a shell command.</p>
<p>Run any command in the shell. The standard output of the command
will be consumed and if there are lines starting with <code>nadi:var:</code>
and followed by <code>key=val</code> pairs, it’ll be read as new attributes
to that node.</p>
<p>For example if a command writes <code>nadi:var:name="Joe"</code> to stdout,
then the for the current node the command is being run for, <code>name</code>
attribute will be set to <code>Joe</code>. This way, you can write your
scripts in any language and pass the values back to the NADI
system.</p>
<p>It will also print out the new values or changes from old values,
if <code>verbose</code> is true.</p>
<h3 id="errors-1"><a class="header" href="#errors-1">Errors</a></h3>
<p>The function will error if,</p>
<ul>
<li>The command template cannot be rendered,</li>
<li>The command cannot be executed,</li>
<li>The attributes from command’s stdout cannot be parsed properly</li>
</ul>
<pre><code class="language-task">network load_str("a -&gt; b");
node command("echo 'nadi:var:sth={NAME}'");
node assert_eq(sth, NAME)
</code></pre>
<h2 id="node.run"><a class="header" href="#node.run">run</a></h2>
<pre><code class="language-sig">node command.run(
    command: '&amp; str',
    inputs: '&amp; str',
    outputs: '&amp; str',
    verbose: 'bool' = true,
    echo: 'bool' = false
)
</code></pre>
<h3 id="arguments-27"><a class="header" href="#arguments-27">Arguments</a></h3>
<ul>
<li><code>command: '&amp; str'</code> =&gt; Node Attribute with the command to run</li>
<li><code>inputs: '&amp; str'</code> =&gt; Node attribute with list of input files</li>
<li><code>outputs: '&amp; str'</code> =&gt; Node attribute with list of output files</li>
<li><code>verbose: 'bool' = true</code> =&gt; Print the command being run</li>
<li><code>echo: 'bool' = false</code> =&gt; Show the output of the command</li>
</ul>
<p>Run the node as if it’s a command if inputs are changed</p>
<p>This function will not run a command node if all outputs are older
than all inputs. This is useful to networks where each nodes are
tasks with input files and output files.</p>
<h1 id="network-functions-3"><a class="header" href="#network-functions-3">Network Functions</a></h1>
<h2 id="network.parallel"><a class="header" href="#network.parallel">parallel</a></h2>
<pre><code class="language-sig">network command.parallel(
    cmd: '&amp; Template',
    workers: 'i64' = 16,
    verbose: 'bool' = true,
    echo: 'bool' = false
)
</code></pre>
<h3 id="arguments-28"><a class="header" href="#arguments-28">Arguments</a></h3>
<ul>
<li><code>cmd: '&amp; Template'</code> =&gt; String Command template to run</li>
<li><code>workers: 'i64' = 16</code> =&gt; Number of workers to run in parallel</li>
<li><code>verbose: 'bool' = true</code> =&gt; Print the command being run</li>
<li><code>echo: 'bool' = false</code> =&gt; Show the output of the command</li>
</ul>
<p>Run the given template as a shell command for each nodes in the network in parallel.</p>
<p>Other than parallel execution this is same as the <code>node</code> function <code>command</code></p>
<pre><code class="language-task">network load_str("a -&gt; b");
network parallel("echo 'nadi:var:sth={NAME}'");
node assert_eq(sth, NAME)
</code></pre>
<h2 id="network.command"><a class="header" href="#network.command">command</a></h2>
<pre><code class="language-sig">network command.command(
    cmd: 'Template',
    verbose: 'bool' = true,
    echo: 'bool' = false
)
</code></pre>
<h3 id="arguments-29"><a class="header" href="#arguments-29">Arguments</a></h3>
<ul>
<li><code>cmd: 'Template'</code> =&gt; String Command template to run</li>
<li><code>verbose: 'bool' = true</code> =&gt; Print the command being run</li>
<li><code>echo: 'bool' = false</code> =&gt; Show the output of the command</li>
</ul>
<p>Run the given template as a shell command.</p>
<p>Run any command in the shell. The standard output of the command
will be consumed and if there are lines starting with <code>nadi:var:</code>
and followed by <code>key=val</code> pairs, it’ll be read as new attributes
to the network. If you want to pass node attributes add node name
with <code>nadi:var:name:</code> as the prefix for <code>key=val</code>.</p>
<p>See <code>node command.command</code> for more details as they have
the same implementation</p>
<p>The examples below run <code>echo</code> command to set the variables, you
can use any command that are scripting languages (python, R,
Julia, etc) or individual programs.</p>
<pre><code class="language-task">network load_str("a -&gt; b");
network command("echo 'nadi:var:sth=123'");
network assert_eq(sth, 123)
network command("echo 'nadi:var:a:sth=123'");
node[a] assert_eq(sth, 123)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-4"><a class="header" href="#network-functions-4">Network Functions</a></h1>
<h2 id="network.load_file"><a class="header" href="#network.load_file">load_file</a></h2>
<pre><code class="language-sig">network connections.load_file(file: 'PathBuf', append: 'bool' = false)
</code></pre>
<h3 id="arguments-30"><a class="header" href="#arguments-30">Arguments</a></h3>
<ul>
<li><code>file: 'PathBuf'</code> =&gt; File to load the network connections from</li>
<li><code>append: 'bool' = false</code> =&gt; Append the connections in the current network</li>
</ul>
<p>Load the given file into the network</p>
<p>This replaces the current network with the one loaded from the
file.</p>
<h2 id="network.load_str"><a class="header" href="#network.load_str">load_str</a></h2>
<pre><code class="language-sig">network connections.load_str(contents: '&amp; str', append: 'bool' = false)
</code></pre>
<h3 id="arguments-31"><a class="header" href="#arguments-31">Arguments</a></h3>
<ul>
<li><code>contents: '&amp; str'</code> =&gt; String containing Network connections</li>
<li><code>append: 'bool' = false</code> =&gt; Append the connections in the current network</li>
</ul>
<p>Load the given file into the network</p>
<p>This replaces the current network with the one loaded from the
file.</p>
<pre><code class="language-task">network load_str("a -&gt; b");
env assert_eq(nodes.NAME, ["b", "a"])
</code></pre>
<h2 id="network.load_edges"><a class="header" href="#network.load_edges">load_edges</a></h2>
<pre><code class="language-sig">network connections.load_edges(edges: '&amp; [(String, String)]', append: 'bool' = false)
</code></pre>
<h3 id="arguments-32"><a class="header" href="#arguments-32">Arguments</a></h3>
<ul>
<li><code>edges: '&amp; [(String, String)]'</code> =&gt; String containing Network connections</li>
<li><code>append: 'bool' = false</code> =&gt; Append the connections in the current network</li>
</ul>
<p>Load the given edges into the network</p>
<p>This replaces the current network with the one loaded from the
file.</p>
<pre><code class="language-task">network load_edges([["a", "b"], ["b", "c"]]);
env assert_eq(nodes.NAME, ["c", "b", "a"])
</code></pre>
<h2 id="network.subset"><a class="header" href="#network.subset">subset</a></h2>
<pre><code class="language-sig">network connections.subset(filter: '&amp; [bool]', keep: 'bool' = true)
</code></pre>
<h3 id="arguments-33"><a class="header" href="#arguments-33">Arguments</a></h3>
<ul>
<li><code>filter: '&amp; [bool]'</code> =&gt;</li>
<li><code>keep: 'bool' = true</code> =&gt; Keep the selected nodes (false = removes the selected)</li>
</ul>
<p>Take a subset of network by only including the selected nodes</p>
<pre><code class="language-task">network load_str("a -&gt; b\n b-&gt;c");
node[a-&gt;b].sth = true;
node[c].sth = false;
network subset(nodes.sth);
env assert_eq(nodes.NAME, ["b", "a"])
</code></pre>
<h2 id="network.save_file"><a class="header" href="#network.save_file">save_file</a></h2>
<pre><code class="language-sig">network connections.save_file(
    file: 'PathBuf',
    quote_all: 'bool' = true,
    graphviz: 'bool' = false
)
</code></pre>
<h3 id="arguments-34"><a class="header" href="#arguments-34">Arguments</a></h3>
<ul>
<li><code>file: 'PathBuf'</code> =&gt; Path to the output file</li>
<li><code>quote_all: 'bool' = true</code> =&gt; quote all node names; if false, doesn’t quote valid identifier names</li>
<li><code>graphviz: 'bool' = false</code> =&gt; wrap the network into a valid graphviz file</li>
</ul>
<p>Save the network into the given file</p>
<p>For more control on graphviz file writing, use
<code>save_graphviz</code> from <code>graphviz</code> plugin instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env-functions-2"><a class="header" href="#env-functions-2">Env Functions</a></h1>
<h2 id="env.count"><a class="header" href="#env.count">count</a></h2>
<pre><code class="language-sig">env core.count(vars: '&amp; [bool]')
</code></pre>
<h3 id="arguments-35"><a class="header" href="#arguments-35">Arguments</a></h3>
<ul>
<li><code>vars: '&amp; [bool]'</code> =&gt;</li>
</ul>
<p>Count the number of true values in the array</p>
<pre><code class="language-task">env assert_eq(count([true, false, true, false]), 2)
</code></pre>
<h2 id="env.type_name"><a class="header" href="#env.type_name">type_name</a></h2>
<pre><code class="language-sig">env core.type_name(value: 'Attribute', recursive: 'bool' = false)
</code></pre>
<h3 id="arguments-36"><a class="header" href="#arguments-36">Arguments</a></h3>
<ul>
<li><code>value: 'Attribute'</code> =&gt; Argument to get type</li>
<li><code>recursive: 'bool' = false</code> =&gt; Recursively check types for array and table</li>
</ul>
<p>Type name of the arguments</p>
<pre><code class="language-task">env assert_eq(type_name(true), "Bool")
env assert_eq(type_name([true, 12]), "Array")
env assert_eq(type_name([true, 12], recursive=true), ["Bool", "Integer"])
env assert_eq(type_name("true"), "String")
</code></pre>
<h2 id="env.isna"><a class="header" href="#env.isna">isna</a></h2>
<pre><code class="language-sig">env core.isna(val: 'f64')
</code></pre>
<h3 id="arguments-37"><a class="header" href="#arguments-37">Arguments</a></h3>
<ul>
<li><code>val: 'f64'</code> =&gt;</li>
</ul>
<p>check if a float is nan</p>
<pre><code class="language-task">env assert(isna(nan + 5))
</code></pre>
<h2 id="env.isinf"><a class="header" href="#env.isinf">isinf</a></h2>
<pre><code class="language-sig">env core.isinf(val: 'f64')
</code></pre>
<h3 id="arguments-38"><a class="header" href="#arguments-38">Arguments</a></h3>
<ul>
<li><code>val: 'f64'</code> =&gt;</li>
</ul>
<p>check if a float is +/- infinity</p>
<pre><code class="language-task">env assert(isinf(12.0 / 0))
</code></pre>
<h2 id="env.float"><a class="header" href="#env.float">float</a></h2>
<pre><code class="language-sig">env core.float(value: 'Attribute', parse: 'bool' = true)
</code></pre>
<h3 id="arguments-39"><a class="header" href="#arguments-39">Arguments</a></h3>
<ul>
<li><code>value: 'Attribute'</code> =&gt; Argument to convert to float</li>
<li><code>parse: 'bool' = true</code> =&gt; parse string to float</li>
</ul>
<p>make a float from value</p>
<pre><code class="language-task">env assert_eq(float(5), 5.0)
env assert_eq(float("5.0"), 5.0)
</code></pre>
<h2 id="env.str"><a class="header" href="#env.str">str</a></h2>
<pre><code class="language-sig">env core.str(value: 'Attribute', quote: 'bool' = false)
</code></pre>
<h3 id="arguments-40"><a class="header" href="#arguments-40">Arguments</a></h3>
<ul>
<li><code>value: 'Attribute'</code> =&gt; Argument to convert to float</li>
<li><code>quote: 'bool' = false</code> =&gt; quote it if it’s literal string</li>
</ul>
<p>make a string from value</p>
<pre><code class="language-task">env assert_eq(str(nan + 5), "nan")
env assert_eq(str(2 + 5), "7")
env assert_eq(str(12.34), "12.34")
env assert_eq(str("nan + 5"), "nan + 5")
env assert_eq(str("true", quote=true), "\"true\"")
</code></pre>
<h2 id="env.int"><a class="header" href="#env.int">int</a></h2>
<pre><code class="language-sig">env core.int(
    value: 'Attribute',
    parse: 'bool' = true,
    round: 'bool' = true,
    strfloat: 'bool' = false
)
</code></pre>
<h3 id="arguments-41"><a class="header" href="#arguments-41">Arguments</a></h3>
<ul>
<li><code>value: 'Attribute'</code> =&gt; Argument to convert to int</li>
<li><code>parse: 'bool' = true</code> =&gt; parse string to int</li>
<li><code>round: 'bool' = true</code> =&gt; round float into integer</li>
<li><code>strfloat: 'bool' = false</code> =&gt; parse string first as float before converting to int</li>
</ul>
<p>make an int from the value</p>
<pre><code class="language-task">env assert_eq(int(5.0), 5)
env assert_eq(int(5.1), 5)
env assert_eq(int("45"), 45)
env assert_eq(int("5.0", strfloat=true), 5)
</code></pre>
<h2 id="env.array"><a class="header" href="#env.array">array</a></h2>
<pre><code class="language-sig">env core.array(*attributes)
</code></pre>
<h3 id="arguments-42"><a class="header" href="#arguments-42">Arguments</a></h3>
<ul>
<li><code>*attributes</code> =&gt; List of attributes</li>
</ul>
<p>make an array from the arguments</p>
<pre><code class="language-task">env assert_eq(array(5, true), [5, true])
</code></pre>
<h2 id="env.attrmap"><a class="header" href="#env.attrmap">attrmap</a></h2>
<pre><code class="language-sig">env core.attrmap(**attributes)
</code></pre>
<h3 id="arguments-43"><a class="header" href="#arguments-43">Arguments</a></h3>
<ul>
<li><code>**attributes</code> =&gt; name and values of attributes</li>
</ul>
<p>make an attrmap from the arguments</p>
<pre><code class="language-task">env assert_eq(attrmap(val=5), {val=5})
</code></pre>
<h2 id="env.json"><a class="header" href="#env.json">json</a></h2>
<pre><code class="language-sig">env core.json(value: 'Attribute')
</code></pre>
<h3 id="arguments-44"><a class="header" href="#arguments-44">Arguments</a></h3>
<ul>
<li><code>value: 'Attribute'</code> =&gt; attribute to format</li>
</ul>
<p>format the attribute as a json string</p>
<pre><code class="language-task">env assert_eq(json(5), "5")
env assert_eq(json([5, true]), "[5, true]")
env assert_eq(json({a=5}), "{\"a\": 5}")
</code></pre>
<h2 id="env.append"><a class="header" href="#env.append">append</a></h2>
<pre><code class="language-sig">env core.append(array: 'Vec &lt; Attribute &gt;', value: 'Attribute')
</code></pre>
<h3 id="arguments-45"><a class="header" href="#arguments-45">Arguments</a></h3>
<ul>
<li><code>array: 'Vec &lt; Attribute &gt;'</code> =&gt; List of attributes</li>
<li><code>value: 'Attribute'</code> =&gt;</li>
</ul>
<p>append a value to an array</p>
<pre><code class="language-task">env assert_eq(append([4], 5), [4, 5])
</code></pre>
<h2 id="env.length"><a class="header" href="#env.length">length</a></h2>
<pre><code class="language-sig">env core.length(value: '&amp; Attribute')
</code></pre>
<h3 id="arguments-46"><a class="header" href="#arguments-46">Arguments</a></h3>
<ul>
<li><code>value: '&amp; Attribute'</code> =&gt; Array or a HashMap</li>
</ul>
<p>length of an array or hashmap</p>
<pre><code class="language-task">env assert_eq(length([4, 5]), 2)
env assert_eq(length({x=4, y=5}), 2)
</code></pre>
<h2 id="env.year"><a class="header" href="#env.year">year</a></h2>
<pre><code class="language-sig">env core.year(value: 'Attribute')
</code></pre>
<h3 id="arguments-47"><a class="header" href="#arguments-47">Arguments</a></h3>
<ul>
<li><code>value: 'Attribute'</code> =&gt; Date or DateTime</li>
</ul>
<p>year from date/datetime</p>
<pre><code class="language-task">env assert_eq(year(1223-12-12), 1223)
env assert_eq(year(1223-12-12T12:12), 1223)
env assert_eq(year(1223-12-12 12:12:08), 1223)
</code></pre>
<h2 id="env.month"><a class="header" href="#env.month">month</a></h2>
<pre><code class="language-sig">env core.month(value: 'Attribute')
</code></pre>
<h3 id="arguments-48"><a class="header" href="#arguments-48">Arguments</a></h3>
<ul>
<li><code>value: 'Attribute'</code> =&gt; Date or DateTime</li>
</ul>
<p>month from date/datetime</p>
<pre><code class="language-task">env assert_eq(month(1223-12-14), 12)
env assert_eq(month(1223-12-14T15:19), 12)
</code></pre>
<h2 id="env.day"><a class="header" href="#env.day">day</a></h2>
<pre><code class="language-sig">env core.day(value: 'Attribute')
</code></pre>
<h3 id="arguments-49"><a class="header" href="#arguments-49">Arguments</a></h3>
<ul>
<li><code>value: 'Attribute'</code> =&gt; Date or DateTime</li>
</ul>
<p>day from date/datetime</p>
<pre><code class="language-task">env assert_eq(day(1223-12-14), 14)
env assert_eq(day(1223-12-14T15:19), 14)
</code></pre>
<h2 id="env.min_num"><a class="header" href="#env.min_num">min_num</a></h2>
<pre><code class="language-sig">env core.min_num(vars: 'Vec &lt; Attribute &gt;', start: 'Attribute' = Float(inf))
</code></pre>
<h3 id="arguments-50"><a class="header" href="#arguments-50">Arguments</a></h3>
<ul>
<li><code>vars: 'Vec &lt; Attribute &gt;'</code> =&gt;</li>
<li><code>start: 'Attribute' = Float(inf)</code> =&gt;</li>
</ul>
<p>Minimum of the variables</p>
<pre><code class="language-task">env assert_eq(min_num([1, 2, 3]), 1)
env assert_eq(min_num([1.0, 2, 3]), 1.0)
env assert_eq(min_num([1, 2, 3], start = 0), 0)
</code></pre>
<h2 id="env.max_num"><a class="header" href="#env.max_num">max_num</a></h2>
<pre><code class="language-sig">env core.max_num(vars: 'Vec &lt; Attribute &gt;', start: 'Attribute' = Float(-inf))
</code></pre>
<h3 id="arguments-51"><a class="header" href="#arguments-51">Arguments</a></h3>
<ul>
<li><code>vars: 'Vec &lt; Attribute &gt;'</code> =&gt;</li>
<li><code>start: 'Attribute' = Float(-inf)</code> =&gt;</li>
</ul>
<p>Minimum of the variables</p>
<pre><code class="language-task">env assert_eq(max_num([1, 2, 3.0]), 3.0)
env assert_eq(max_num([1.0, 2, 3]), 3)
env assert_eq(max_num([1, inf, 3], 0), inf)
</code></pre>
<h2 id="env.min"><a class="header" href="#env.min">min</a></h2>
<pre><code class="language-sig">env core.min(vars: 'Vec &lt; Attribute &gt;', start: 'Attribute')
</code></pre>
<h3 id="arguments-52"><a class="header" href="#arguments-52">Arguments</a></h3>
<ul>
<li><code>vars: 'Vec &lt; Attribute &gt;'</code> =&gt;</li>
<li><code>start: 'Attribute'</code> =&gt;</li>
</ul>
<p>Minimum of the variables</p>
<pre><code class="language-task">env assert_eq(min([1, 2, 3], 100), 1)
env assert_eq(min([1.0, 2, 3], 100), 1.0)
env assert_eq(min([1, 2, 3], inf), 1)
env assert_eq(min(["b", "a", "d"], "zzz"), "a")
</code></pre>
<h2 id="env.max"><a class="header" href="#env.max">max</a></h2>
<pre><code class="language-sig">env core.max(vars: 'Vec &lt; Attribute &gt;', start: 'Attribute')
</code></pre>
<h3 id="arguments-53"><a class="header" href="#arguments-53">Arguments</a></h3>
<ul>
<li><code>vars: 'Vec &lt; Attribute &gt;'</code> =&gt;</li>
<li><code>start: 'Attribute'</code> =&gt;</li>
</ul>
<p>Maximum of the variables</p>
<pre><code class="language-task">env assert_eq(max([1, 2, 3], -1), 3)
env assert_eq(max([1.0, 2, 3], -1), 3)
env assert_eq(max([1, 2, 3], -inf), 3)
env assert_eq(max(["b", "a", "d"], ""), "d")
</code></pre>
<h2 id="env.sum"><a class="header" href="#env.sum">sum</a></h2>
<pre><code class="language-sig">env core.sum(vars: 'Vec &lt; Attribute &gt;', start: 'Attribute' = Integer(0))
</code></pre>
<h3 id="arguments-54"><a class="header" href="#arguments-54">Arguments</a></h3>
<ul>
<li><code>vars: 'Vec &lt; Attribute &gt;'</code> =&gt;</li>
<li><code>start: 'Attribute' = Integer(0)</code> =&gt;</li>
</ul>
<p>Sum of the variables</p>
<p>This function is for numeric attributes. You need to give the
start attribute so that data type is valid.</p>
<pre><code class="language-task">env assert_eq(sum([2, 3, 4]), 9)
env assert_eq(sum([2, 3, 4], start=0.0), 9.0)
</code></pre>
<h2 id="env.prod"><a class="header" href="#env.prod">prod</a></h2>
<pre><code class="language-sig">env core.prod(vars: 'Vec &lt; Attribute &gt;', start: 'Attribute' = Integer(1))
</code></pre>
<h3 id="arguments-55"><a class="header" href="#arguments-55">Arguments</a></h3>
<ul>
<li><code>vars: 'Vec &lt; Attribute &gt;'</code> =&gt;</li>
<li><code>start: 'Attribute' = Integer(1)</code> =&gt;</li>
</ul>
<p>Product of the variables</p>
<p>This function is for numerical values/attributes</p>
<pre><code class="language-task">env assert_eq(prod([1, 2, 3]), 6)
env assert_eq(prod([1.0, 2, 3]), 6.0)
</code></pre>
<h2 id="env.unique_str"><a class="header" href="#env.unique_str">unique_str</a></h2>
<pre><code class="language-sig">env core.unique_str(vars: 'Vec &lt; String &gt;')
</code></pre>
<h3 id="arguments-56"><a class="header" href="#arguments-56">Arguments</a></h3>
<ul>
<li><code>vars: 'Vec &lt; String &gt;'</code> =&gt;</li>
</ul>
<p>Get a list of unique string values</p>
<p>The order of the strings returned is not guaranteed</p>
<pre><code class="language-task">env.uniq = unique_str(["hi", "me", "hi", "you"]);
env assert_eq(length(uniq), 3)
</code></pre>
<h2 id="env.count_str"><a class="header" href="#env.count_str">count_str</a></h2>
<pre><code class="language-sig">env core.count_str(vars: 'Vec &lt; String &gt;')
</code></pre>
<h3 id="arguments-57"><a class="header" href="#arguments-57">Arguments</a></h3>
<ul>
<li><code>vars: 'Vec &lt; String &gt;'</code> =&gt;</li>
</ul>
<p>Get a count of unique string values</p>
<pre><code class="language-task">env assert_eq(
count_str(["Hi", "there", "Deliah", "Hi"]),
{Hi = 2, there = 1, Deliah=1}
)
</code></pre>
<h2 id="env.concat"><a class="header" href="#env.concat">concat</a></h2>
<pre><code class="language-sig">env core.concat(*vars, join: '&amp; str' = "")
</code></pre>
<h3 id="arguments-58"><a class="header" href="#arguments-58">Arguments</a></h3>
<ul>
<li><code>*vars</code> =&gt;</li>
<li><code>join: '&amp; str' = ""</code> =&gt;</li>
</ul>
<p>Concat the strings</p>
<pre><code class="language-task">env assert_eq(concat("Hello", "World", join=" "), "Hello World")
</code></pre>
<h2 id="env.range"><a class="header" href="#env.range">range</a></h2>
<pre><code class="language-sig">env core.range(start: 'i64', end: 'i64')
</code></pre>
<h3 id="arguments-59"><a class="header" href="#arguments-59">Arguments</a></h3>
<ul>
<li><code>start: 'i64'</code> =&gt;</li>
<li><code>end: 'i64'</code> =&gt;</li>
</ul>
<p>Generate integer array, end is not included</p>
<pre><code class="language-task">env assert_eq(range(1, 5), [1, 2, 3, 4])
</code></pre>
<h2 id="env.assert"><a class="header" href="#env.assert">assert</a></h2>
<pre><code class="language-sig">env core.assert(condition: 'bool', note: 'String' = "Condition False")
</code></pre>
<h3 id="arguments-60"><a class="header" href="#arguments-60">Arguments</a></h3>
<ul>
<li><code>condition: 'bool'</code> =&gt;</li>
<li><code>note: 'String' = "Condition False"</code> =&gt;</li>
</ul>
<p>Assert the condition is true</p>
<p>Use <code>assert_eq</code>/<code>assert_neq</code> if you are testing equality for
better error message.</p>
<pre><code class="language-task">env assert(true)
</code></pre>
<h2 id="env.assert_eq"><a class="header" href="#env.assert_eq">assert_eq</a></h2>
<pre><code class="language-sig">env core.assert_eq(left: 'Attribute', right: 'Attribute')
</code></pre>
<h3 id="arguments-61"><a class="header" href="#arguments-61">Arguments</a></h3>
<ul>
<li><code>left: 'Attribute'</code> =&gt;</li>
<li><code>right: 'Attribute'</code> =&gt;</li>
</ul>
<p>Assert the two values are equal</p>
<p>This function is for testing the code, as well as for
terminating the execution when certain values are not equal</p>
<pre><code class="language-task">env assert_eq(1, 1)
env assert_eq(true, 1 &gt; 0)
env assert_eq("string val", concat("string", " ", "val"))
</code></pre>
<h2 id="env.assert_neq"><a class="header" href="#env.assert_neq">assert_neq</a></h2>
<pre><code class="language-sig">env core.assert_neq(left: 'Attribute', right: 'Attribute')
</code></pre>
<h3 id="arguments-62"><a class="header" href="#arguments-62">Arguments</a></h3>
<ul>
<li><code>left: 'Attribute'</code> =&gt;</li>
<li><code>right: 'Attribute'</code> =&gt;</li>
</ul>
<p>Assert the two values are not equal</p>
<p>This function is for testing the code, as well as for
terminating the execution when certain values are not equal</p>
<pre><code class="language-task">env assert_neq(1, 1.0)
env assert_neq(true, 1 &lt; 0)
env assert_neq("string val", concat("string", "val"))
</code></pre>
<h1 id="node-functions-4"><a class="header" href="#node-functions-4">Node Functions</a></h1>
<h2 id="node.inputs_count"><a class="header" href="#node.inputs_count">inputs_count</a></h2>
<pre><code class="language-sig">node core.inputs_count()
</code></pre>
<h3 id="arguments-63"><a class="header" href="#arguments-63">Arguments</a></h3>
<p>Count the number of input nodes in the node</p>
<pre><code class="language-task">network load_str("a -&gt; b\n b -&gt; d\n c -&gt; d")
node assert_eq(inputs_count(), length(inputs._))
</code></pre>
<h2 id="node.inputs_attr"><a class="header" href="#node.inputs_attr">inputs_attr</a></h2>
<pre><code class="language-sig">node core.inputs_attr(attr: 'String' = "NAME")
</code></pre>
<h3 id="arguments-64"><a class="header" href="#arguments-64">Arguments</a></h3>
<ul>
<li><code>attr: 'String' = "NAME"</code> =&gt; Attribute to get from inputs</li>
</ul>
<p>Get attributes of the input nodes</p>
<p>This is equivalent to using the <code>inputs</code> keyword</p>
<pre><code class="language-task">network load_str("a -&gt; b\n b -&gt; d\n c -&gt; d")
node assert_eq(inputs_attr("NAME"), inputs.NAME)
</code></pre>
<h2 id="node.has_outlet"><a class="header" href="#node.has_outlet">has_outlet</a></h2>
<pre><code class="language-sig">node core.has_outlet()
</code></pre>
<h3 id="arguments-65"><a class="header" href="#arguments-65">Arguments</a></h3>
<p>Node has an outlet or not</p>
<p>This is equivalent to using <code>output._?</code>, as <code>_</code> is a dummy
variable that will always be present in all cases, it being
absent is because there is no output/outlet of that node.</p>
<pre><code class="language-task">network load_str("a -&gt; b\n b -&gt; d\n c -&gt; d")
node assert_eq(has_outlet(), output._?)
</code></pre>
<h2 id="node.output_attr"><a class="header" href="#node.output_attr">output_attr</a></h2>
<pre><code class="language-sig">node core.output_attr(attr: 'String' = "NAME")
</code></pre>
<h3 id="arguments-66"><a class="header" href="#arguments-66">Arguments</a></h3>
<ul>
<li><code>attr: 'String' = "NAME"</code> =&gt; Attribute to get from inputs</li>
</ul>
<p>Get attributes of the output node</p>
<p>This is equivalent to using the <code>output</code> keyword</p>
<pre><code class="language-task">network load_str("a -&gt; b\n b -&gt; d\n c -&gt; d")
node(output._?) assert_eq(output_attr("NAME"), output.NAME)
</code></pre>
<h1 id="network-functions-5"><a class="header" href="#network-functions-5">Network Functions</a></h1>
<h2 id="network.count"><a class="header" href="#network.count">count</a></h2>
<pre><code class="language-sig">network core.count(vars: 'Option &lt; Vec &lt; bool &gt; &gt;')
</code></pre>
<h3 id="arguments-67"><a class="header" href="#arguments-67">Arguments</a></h3>
<ul>
<li><code>vars: 'Option &lt; Vec &lt; bool &gt; &gt;'</code> =&gt;</li>
</ul>
<p>Count the number of nodes in the network</p>
<pre><code class="language-task">network assert_eq(count(), 0)
network load_str("a -&gt; b")
network assert_eq(count(), 2)
node.sel = INDEX &lt; 1
network assert_eq(count(nodes.sel), 1)
</code></pre>
<h2 id="network.outlet"><a class="header" href="#network.outlet">outlet</a></h2>
<pre><code class="language-sig">network core.outlet()
</code></pre>
<h3 id="arguments-68"><a class="header" href="#arguments-68">Arguments</a></h3>
<p>Get the name of the outlet node</p>
<pre><code class="language-task">network load_str("a -&gt; b")
network assert_eq(outlet(), "b")
</code></pre>
<h2 id="network.node_attr"><a class="header" href="#network.node_attr">node_attr</a></h2>
<pre><code class="language-sig">network core.node_attr(name: 'String', attribute: 'String' = "_")
</code></pre>
<h3 id="arguments-69"><a class="header" href="#arguments-69">Arguments</a></h3>
<ul>
<li><code>name: 'String'</code> =&gt; name of the node</li>
<li><code>attribute: 'String' = "_"</code> =&gt; attribute to get</li>
</ul>
<p>Get the attr of the provided node</p>
<pre><code class="language-task">network load_str("a -&gt; b")
network assert_eq(node_attr("a", "NAME"), "a")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env-functions-3"><a class="header" href="#env-functions-3">Env Functions</a></h1>
<h2 id="env.sleep"><a class="header" href="#env.sleep">sleep</a></h2>
<pre><code class="language-sig">env debug.sleep(time: 'u64' = 1000)
</code></pre>
<h3 id="arguments-70"><a class="header" href="#arguments-70">Arguments</a></h3>
<ul>
<li><code>time: 'u64' = 1000</code> =&gt;</li>
</ul>
<p>sleep for given number of milliseconds</p>
<h2 id="env.debug"><a class="header" href="#env.debug">debug</a></h2>
<pre><code class="language-sig">env debug.debug(*args, **kwargs)
</code></pre>
<h3 id="arguments-71"><a class="header" href="#arguments-71">Arguments</a></h3>
<ul>
<li><code>*args</code> =&gt; Function arguments</li>
<li><code>**kwargs</code> =&gt; Function Keyword arguments</li>
</ul>
<p>Print the args and kwargs on this function</p>
<p>This function will just print out the args and kwargs the
function is called with. This is for debugging purposes to see
if the args/kwargs are identified properly. And can also be
used to see how the nadi system takes the input from the
function call.</p>
<h2 id="env.echo"><a class="header" href="#env.echo">echo</a></h2>
<pre><code class="language-sig">env debug.echo(
    line: 'String',
    error: 'bool' = false,
    newline: 'bool' = true
)
</code></pre>
<h3 id="arguments-72"><a class="header" href="#arguments-72">Arguments</a></h3>
<ul>
<li><code>line: 'String'</code> =&gt; line to print</li>
<li><code>error: 'bool' = false</code> =&gt; print to stderr instead of stdout</li>
<li><code>newline: 'bool' = true</code> =&gt; print newline at the end</li>
</ul>
<p>Echo the string to stdout or stderr</p>
<p>This simply echoes anything given to it. This can be used in
combination with nadi tasks that create files (image, text,
etc). The <code>echo</code> function can be called to get the link to
those files back to the stdout.</p>
<p>Also useful for nadi preprocessor.</p>
<h2 id="env.clip"><a class="header" href="#env.clip">clip</a></h2>
<pre><code class="language-sig">env debug.clip(error: 'bool' = false)
</code></pre>
<h3 id="arguments-73"><a class="header" href="#arguments-73">Arguments</a></h3>
<ul>
<li><code>error: 'bool' = false</code> =&gt; print in stderr instead of in stdout</li>
</ul>
<p>Echo the ––8&lt;–– line for clipping syntax</p>
<p>This function is a utility function for the generation of nadi
book. This prints out the <code>----8&lt;----</code> line when called, so
that <code>mdbook</code> preprocessor for <code>nadi</code> knows where to clip the
output for displaying it in the book.</p>
<p>This makes it easier to only show the relevant parts of the
output in the documentation instead of having the user see
output of other unrelated parts which are necessary for
generating the results.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>Given the following tasks file:</p>
<pre><code class="language-task ignore">net load_file("...")
net load_attrs("...")
net clip()
net render("{_NAME} {attr1}")
</code></pre>
<p>The clip function’s output will let the preprocessor know that
only the parts after that are relevant to the user. Hence,
it’ll discard outputs before that during documentation
generation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env-functions-4"><a class="header" href="#env-functions-4">Env Functions</a></h1>
<h2 id="env.ifelse"><a class="header" href="#env.ifelse">ifelse</a></h2>
<pre><code class="language-sig">env logic.ifelse(
    cond: 'bool',
    iftrue: 'Attribute',
    iffalse: 'Attribute'
)
</code></pre>
<h3 id="arguments-74"><a class="header" href="#arguments-74">Arguments</a></h3>
<ul>
<li><code>cond: 'bool'</code> =&gt; Attribute that can be cast to bool value</li>
<li><code>iftrue: 'Attribute'</code> =&gt; Output if <code>cond</code> is true</li>
<li><code>iffalse: 'Attribute'</code> =&gt; Output if <code>cond</code> is false</li>
</ul>
<p>Simple if else condition</p>
<p>This is similar to using the <code>if-else</code> expression, the
difference being the condition is relaxed. For example, for
<code>if-else</code> the condition should be true or false, but for this
function, the attribute can be anything that can be cast as
true or false. (e.g. 1 =&gt; true, 0 =&gt; false)</p>
<pre><code class="language-task">env assert_eq(ifelse(true, 1, 2), 1)
env assert_eq(ifelse(false, 1, 2), 2)
env assert_eq(ifelse(100.0, 1, 2), 1)
env assert_eq(ifelse(true, 1, 2), if (true) {1} else {2})
</code></pre>
<h2 id="env.gt"><a class="header" href="#env.gt">gt</a></h2>
<pre><code class="language-sig">env logic.gt(a: '&amp; Attribute', b: '&amp; Attribute')
</code></pre>
<h3 id="arguments-75"><a class="header" href="#arguments-75">Arguments</a></h3>
<ul>
<li><code>a: '&amp; Attribute'</code> =&gt; first attribute</li>
<li><code>b: '&amp; Attribute'</code> =&gt; second attribute</li>
</ul>
<p>Greater than check</p>
<pre><code class="language-task">env assert_eq(gt(1, 2), 1 &gt; 2)
env assert_eq(gt(1.0, 20), 1.0 &gt; 20)
</code></pre>
<h2 id="env.lt"><a class="header" href="#env.lt">lt</a></h2>
<pre><code class="language-sig">env logic.lt(a: '&amp; Attribute', b: '&amp; Attribute')
</code></pre>
<h3 id="arguments-76"><a class="header" href="#arguments-76">Arguments</a></h3>
<ul>
<li><code>a: '&amp; Attribute'</code> =&gt; first attribute</li>
<li><code>b: '&amp; Attribute'</code> =&gt; second attribute</li>
</ul>
<p>Less than check</p>
<pre><code class="language-task">env assert_eq(lt(1, 2), 1 &lt; 2)
env assert_eq(lt(1.0, 20), 1.0 &lt; 20)
</code></pre>
<h2 id="env.eq"><a class="header" href="#env.eq">eq</a></h2>
<pre><code class="language-sig">env logic.eq(a: '&amp; Attribute', b: '&amp; Attribute')
</code></pre>
<h3 id="arguments-77"><a class="header" href="#arguments-77">Arguments</a></h3>
<ul>
<li><code>a: '&amp; Attribute'</code> =&gt; first attribute</li>
<li><code>b: '&amp; Attribute'</code> =&gt; second attribute</li>
</ul>
<p>Equality than check</p>
<pre><code class="language-task">env assert_eq(eq(1, 2), 1 == 2)
env assert_eq(eq(2.0, 2.0), 2.0 == 2.0)
env assert_eq(eq(2.0, 2), 2.0 == 2)
</code></pre>
<h2 id="env.and"><a class="header" href="#env.and">and</a></h2>
<pre><code class="language-sig">env logic.and(*conds)
</code></pre>
<h3 id="arguments-78"><a class="header" href="#arguments-78">Arguments</a></h3>
<ul>
<li><code>*conds</code> =&gt; List of attributes that can be cast to bool</li>
</ul>
<p>Boolean and</p>
<p>Similar to the operator <code>&amp;</code> but the values are cast to boolean</p>
<pre><code class="language-task">env assert_eq(and(true, true), true)
env assert_eq(and(true, false), false)
env assert_eq(and(true, false), false &amp; true)
</code></pre>
<h2 id="env.or"><a class="header" href="#env.or">or</a></h2>
<pre><code class="language-sig">env logic.or(*conds)
</code></pre>
<h3 id="arguments-79"><a class="header" href="#arguments-79">Arguments</a></h3>
<ul>
<li><code>*conds</code> =&gt; List of attributes that can be cast to bool</li>
</ul>
<p>boolean or</p>
<p>Similar to the operator <code>|</code> but the values are cast to boolean</p>
<pre><code class="language-task">env assert_eq(or(true, false), true)
env assert_eq(or(false, false), false)
env assert_eq(or(true, false), false | true)
</code></pre>
<h2 id="env.not"><a class="header" href="#env.not">not</a></h2>
<pre><code class="language-sig">env logic.not(cond: 'bool')
</code></pre>
<h3 id="arguments-80"><a class="header" href="#arguments-80">Arguments</a></h3>
<ul>
<li><code>cond: 'bool'</code> =&gt; attribute that can be cast to bool</li>
</ul>
<p>boolean not</p>
<p>Similar to the operator <code>!</code> but the values are cast to boolean</p>
<pre><code class="language-task">env assert_eq(not(true), false)
env assert_eq(not(false), true)
env assert_eq(not(true), !true)
env assert_eq(not(false), !false)
</code></pre>
<h2 id="env.all"><a class="header" href="#env.all">all</a></h2>
<pre><code class="language-sig">env logic.all(vars: '&amp; [bool]')
</code></pre>
<h3 id="arguments-81"><a class="header" href="#arguments-81">Arguments</a></h3>
<ul>
<li><code>vars: '&amp; [bool]'</code> =&gt;</li>
</ul>
<p>check if all of the bool are true</p>
<pre><code class="language-task">env assert_eq(all([true]), true)
env assert_eq(all([false, true]), false)
env assert_eq(all([true, true]), true)
env assert_eq(all([false]), false)
</code></pre>
<h2 id="env.any"><a class="header" href="#env.any">any</a></h2>
<pre><code class="language-sig">env logic.any(vars: '&amp; [bool]')
</code></pre>
<h3 id="arguments-82"><a class="header" href="#arguments-82">Arguments</a></h3>
<ul>
<li><code>vars: '&amp; [bool]'</code> =&gt;</li>
</ul>
<p>check if any of the bool are true</p>
<pre><code class="language-task">env assert_eq(any([true]), true)
env assert_eq(any([false, true]), true)
env assert_eq(any([false, false]), false)
env assert_eq(any([false]), false)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env-functions-5"><a class="header" href="#env-functions-5">Env Functions</a></h1>
<h2 id="env.str_filter"><a class="header" href="#env.str_filter">str_filter</a></h2>
<pre><code class="language-sig">env regex.str_filter(attrs: 'Vec &lt; String &gt;', pattern: 'Regex')
</code></pre>
<h3 id="arguments-83"><a class="header" href="#arguments-83">Arguments</a></h3>
<ul>
<li><code>attrs: 'Vec &lt; String &gt;'</code> =&gt; attribute to check for pattern</li>
<li><code>pattern: 'Regex'</code> =&gt; Regex pattern to match</li>
</ul>
<p>Filter from the string list with only the values matching pattern</p>
<pre><code class="language-task">env assert_eq(str_filter(["abc", "and", "xyz"], "^a"), ["abc", "and"])
</code></pre>
<h2 id="env.str_match"><a class="header" href="#env.str_match">str_match</a></h2>
<pre><code class="language-sig">env regex.str_match(attr: '&amp; str', pattern: 'Regex')
</code></pre>
<h3 id="arguments-84"><a class="header" href="#arguments-84">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; attribute to check for pattern</li>
<li><code>pattern: 'Regex'</code> =&gt; Regex pattern to match</li>
</ul>
<p>Check if the given pattern matches the value or not</p>
<p>You can also use match operator for this</p>
<pre><code class="language-task">env assert_eq(str_match("abc", "^a"), true)
env assert_eq(str_match("abc", "^a"), "abc" match "^a")
</code></pre>
<h2 id="env.str_replace"><a class="header" href="#env.str_replace">str_replace</a></h2>
<pre><code class="language-sig">env regex.str_replace(
    attr: '&amp; str',
    pattern: 'Regex',
    rep: '&amp; str'
)
</code></pre>
<h3 id="arguments-85"><a class="header" href="#arguments-85">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; original string</li>
<li><code>pattern: 'Regex'</code> =&gt; Regex pattern to match</li>
<li><code>rep: '&amp; str'</code> =&gt; replacement string</li>
</ul>
<p>Replace the occurances of the given match</p>
<pre><code class="language-task">env assert_eq(str_replace("abc", "^a", 2), "2bc")
env assert_eq(str_replace("abc", "[abc]", 2), "222")
</code></pre>
<h2 id="env.str_find"><a class="header" href="#env.str_find">str_find</a></h2>
<pre><code class="language-sig">env regex.str_find(attr: '&amp; str', pattern: 'Regex')
</code></pre>
<h3 id="arguments-86"><a class="header" href="#arguments-86">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; attribute to check for pattern</li>
<li><code>pattern: 'Regex'</code> =&gt; Regex pattern to match</li>
</ul>
<p>Find the given pattern in the value</p>
<pre><code class="language-task">env assert_eq(str_find("abc", "^[ab]"), "a")
</code></pre>
<h2 id="env.str_find_all"><a class="header" href="#env.str_find_all">str_find_all</a></h2>
<pre><code class="language-sig">env regex.str_find_all(attr: '&amp; str', pattern: 'Regex')
</code></pre>
<h3 id="arguments-87"><a class="header" href="#arguments-87">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; attribute to check for pattern</li>
<li><code>pattern: 'Regex'</code> =&gt; Regex pattern to match</li>
</ul>
<p>Find all the matches of the given pattern in the value</p>
<pre><code class="language-task">env assert_eq(str_find_all("abc", "[ab]"), ["a", "b"])
</code></pre>
<h2 id="env.str_count"><a class="header" href="#env.str_count">str_count</a></h2>
<pre><code class="language-sig">env regex.str_count(attr: '&amp; str', pattern: 'Regex')
</code></pre>
<h3 id="arguments-88"><a class="header" href="#arguments-88">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; attribute to check for pattern</li>
<li><code>pattern: 'Regex'</code> =&gt; Regex pattern to match</li>
</ul>
<p>Count the number of matches of given pattern in the string</p>
<pre><code class="language-task">env assert_eq(str_count("abc", "[ab]"), 2)
</code></pre>
<h2 id="env.str_split"><a class="header" href="#env.str_split">str_split</a></h2>
<pre><code class="language-sig">env regex.str_split(
    attr: '&amp; str',
    pattern: 'Regex',
    limit: 'Option &lt; usize &gt;'
)
</code></pre>
<h3 id="arguments-89"><a class="header" href="#arguments-89">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt; String to split</li>
<li><code>pattern: 'Regex'</code> =&gt; Regex pattern to split with</li>
<li><code>limit: 'Option &lt; usize &gt;'</code> =&gt; Limit the split to maximum number</li>
</ul>
<p>Split the string with the given pattern</p>
<pre><code class="language-task">env assert_eq(str_split("abc", "^[ab]"), ["", "bc"])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env-functions-6"><a class="header" href="#env-functions-6">Env Functions</a></h1>
<h2 id="env.render"><a class="header" href="#env.render">render</a></h2>
<pre><code class="language-sig">env render.render(
    template: '&amp; Template',
    safe: 'bool' = false,
    **keyval
)
</code></pre>
<h3 id="arguments-90"><a class="header" href="#arguments-90">Arguments</a></h3>
<ul>
<li><code>template: '&amp; Template'</code> =&gt; String template to render</li>
<li><code>safe: 'bool' = false</code> =&gt; if render fails keep it as it is instead of exiting</li>
<li><code>**keyval</code> =&gt;</li>
</ul>
<p>Render the template based on the node attributes</p>
<p>For more details on the template system. Refer to the String
Template section of the NADI book.</p>
<pre><code class="language-task">env assert_eq(render("abc {_x}", x="ab"), "abc ab")
env assert_eq(render("abc {x}", x=23), "abc 23")
</code></pre>
<p>If safe parameter is true, then it doesn’t error out even if
the variable is not present, and will just return the original
template. By default it errors out if there are any variables
in the template without a value.</p>
<pre><code class="language-task">env assert_eq(render("abc {x}", safe=true), "abc {x}")
</code></pre>
<h1 id="node-functions-5"><a class="header" href="#node-functions-5">Node Functions</a></h1>
<h2 id="node.render"><a class="header" href="#node.render">render</a></h2>
<pre><code class="language-sig">node render.render(template: '&amp; Template', safe: 'bool' = false)
</code></pre>
<h3 id="arguments-91"><a class="header" href="#arguments-91">Arguments</a></h3>
<ul>
<li><code>template: '&amp; Template'</code> =&gt; String template to render</li>
<li><code>safe: 'bool' = false</code> =&gt; if render fails keep it as it is instead of exiting</li>
</ul>
<p>Render the template based on the node attributes</p>
<p>For more details on the template system. Refer to the String
Template section of the NADI book.</p>
<pre><code class="language-task">network load_str("a -&gt; b")
node.x = 13
node assert_eq(render("abc {x}"), "abc 13")
</code></pre>
<h1 id="network-functions-6"><a class="header" href="#network-functions-6">Network Functions</a></h1>
<h2 id="network.render"><a class="header" href="#network.render">render</a></h2>
<pre><code class="language-sig">network render.render(template: '&amp; Template', safe: 'bool' = false)
</code></pre>
<h3 id="arguments-92"><a class="header" href="#arguments-92">Arguments</a></h3>
<ul>
<li><code>template: '&amp; Template'</code> =&gt; Path to the template file</li>
<li><code>safe: 'bool' = false</code> =&gt; if render fails keep it as it is instead of exiting</li>
</ul>
<p>Render from network attributes</p>
<pre><code class="language-task">network.x = 13
network assert_eq(render("abc {x}"), "abc 13")
</code></pre>
<h2 id="network.render_nodes"><a class="header" href="#network.render_nodes">render_nodes</a></h2>
<pre><code class="language-sig">network render.render_nodes(
    template: '&amp; Template',
    safe: 'bool' = false,
    join: '&amp; str' = "\n"
)
</code></pre>
<h3 id="arguments-93"><a class="header" href="#arguments-93">Arguments</a></h3>
<ul>
<li><code>template: '&amp; Template'</code> =&gt; Path to the template file</li>
<li><code>safe: 'bool' = false</code> =&gt; if render fails keep it as it is instead of exiting</li>
<li><code>join: '&amp; str' = "\n"</code> =&gt; String to join the render results</li>
</ul>
<p>Render each node of the network and combine to same variable</p>
<pre><code class="language-task">network load_str("a -&gt; b")
node.x = INDEX + 1
network assert_eq(render_nodes("abc {x}"), "abc 1\nabc 2")
</code></pre>
<h2 id="network.render_template"><a class="header" href="#network.render_template">render_template</a></h2>
<pre><code class="language-sig">network render.render_template(template: 'PathBuf')
</code></pre>
<h3 id="arguments-94"><a class="header" href="#arguments-94">Arguments</a></h3>
<ul>
<li><code>template: 'PathBuf'</code> =&gt; Path to the template file</li>
</ul>
<p>Render a File template for the nodes in the whole network</p>
<p>Write the file with templates for input variables in the same
way you write string templates. It’s useful for markdown
files, as the curly braces syntax won’t be used for anything
else that way. Do be careful about that. And the program will
replace those templates with their values when you run it with
inputs.</p>
<p>It’ll repeat the same template for each node and render them.
If you want only a portion of the file repeated for nodes
inclose them with lines with <code>---8&lt;---</code> on both start and the
end. The lines containing the clip syntax will be ignored,
ideally you can put them in comments.</p>
<p>You can also use <code>---include:&lt;filename&gt;[::line_range]</code> syntax to
include a file, the line_range syntax, if present, should be
in the form of <code>start[:increment]:end</code>, you can exclude start
or end to denote the line 1 or last line (e.g. <code>:5</code> is 1:5,
and <code>3:</code> is from line 3 to the end)</p>
<h3 id="arguments-95"><a class="header" href="#arguments-95">Arguments</a></h3>
<ul>
<li><code>template</code>: Path to the template file</li>
<li><code>outfile</code> [Optional]: Path to save the template file, if none it’ll be printed in stdout</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-6"><a class="header" href="#node-functions-6">Node Functions</a></h1>
<h2 id="node.sr_count"><a class="header" href="#node.sr_count">sr_count</a></h2>
<pre><code class="language-sig">node series.sr_count()
</code></pre>
<h3 id="arguments-96"><a class="header" href="#arguments-96">Arguments</a></h3>
<p>Number of series in the node</p>
<h2 id="node.sr_list"><a class="header" href="#node.sr_list">sr_list</a></h2>
<pre><code class="language-sig">node series.sr_list()
</code></pre>
<h3 id="arguments-97"><a class="header" href="#arguments-97">Arguments</a></h3>
<p>List all series in the node</p>
<h2 id="node.sr_dtype"><a class="header" href="#node.sr_dtype">sr_dtype</a></h2>
<pre><code class="language-sig">node series.sr_dtype(name: '&amp; str', safe: 'bool' = false)
</code></pre>
<h3 id="arguments-98"><a class="header" href="#arguments-98">Arguments</a></h3>
<ul>
<li><code>name: '&amp; str'</code> =&gt; Name of the series</li>
<li><code>safe: 'bool' = false</code> =&gt; Do not error if series does’t exist</li>
</ul>
<p>Type name of the series</p>
<h2 id="node.sr_len"><a class="header" href="#node.sr_len">sr_len</a></h2>
<pre><code class="language-sig">node series.sr_len(name: '&amp; str', safe: 'bool' = false)
</code></pre>
<h3 id="arguments-99"><a class="header" href="#arguments-99">Arguments</a></h3>
<ul>
<li><code>name: '&amp; str'</code> =&gt; Name of the series</li>
<li><code>safe: 'bool' = false</code> =&gt; Do not error if series does’t exist</li>
</ul>
<p>Length of the series</p>
<h2 id="node.sr_mean"><a class="header" href="#node.sr_mean">sr_mean</a></h2>
<pre><code class="language-sig">node series.sr_mean(name: '&amp; str')
</code></pre>
<h3 id="arguments-100"><a class="header" href="#arguments-100">Arguments</a></h3>
<ul>
<li><code>name: '&amp; str'</code> =&gt; Name of the series</li>
</ul>
<p>Type name of the series</p>
<h2 id="node.sr_sum"><a class="header" href="#node.sr_sum">sr_sum</a></h2>
<pre><code class="language-sig">node series.sr_sum(name: '&amp; str')
</code></pre>
<h3 id="arguments-101"><a class="header" href="#arguments-101">Arguments</a></h3>
<ul>
<li><code>name: '&amp; str'</code> =&gt; Name of the series</li>
</ul>
<p>Sum of the series</p>
<h2 id="node.set_series"><a class="header" href="#node.set_series">set_series</a></h2>
<pre><code class="language-sig">node series.set_series(
    name: '&amp; str',
    value: 'Attribute',
    dtype: '&amp; str'
)
</code></pre>
<h3 id="arguments-102"><a class="header" href="#arguments-102">Arguments</a></h3>
<ul>
<li><code>name: '&amp; str'</code> =&gt; Name of the series to save as</li>
<li><code>value: 'Attribute'</code> =&gt; Argument to convert to series</li>
<li><code>dtype: '&amp; str'</code> =&gt; type</li>
</ul>
<p>set the following series to the node</p>
<h2 id="node.sr_to_array"><a class="header" href="#node.sr_to_array">sr_to_array</a></h2>
<pre><code class="language-sig">node series.sr_to_array(name: '&amp; str', safe: 'bool' = false)
</code></pre>
<h3 id="arguments-103"><a class="header" href="#arguments-103">Arguments</a></h3>
<ul>
<li><code>name: '&amp; str'</code> =&gt; Name of the series</li>
<li><code>safe: 'bool' = false</code> =&gt; Do not error if series does’t exist</li>
</ul>
<p>Make an array from the series</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-7"><a class="header" href="#network-functions-7">Network Functions</a></h1>
<h2 id="network.save_csv"><a class="header" href="#network.save_csv">save_csv</a></h2>
<pre><code class="language-sig">network table.save_csv(
    path: '&amp; Path',
    fields: '&amp; [String]',
    filter: 'Option &lt; Vec &lt; bool &gt; &gt;'
)
</code></pre>
<h3 id="arguments-104"><a class="header" href="#arguments-104">Arguments</a></h3>
<ul>
<li><code>path: '&amp; Path'</code> =&gt;</li>
<li><code>fields: '&amp; [String]'</code> =&gt;</li>
<li><code>filter: 'Option &lt; Vec &lt; bool &gt; &gt;'</code> =&gt;</li>
</ul>
<p>Save CSV</p>
<h2 id="network.table_to_markdown"><a class="header" href="#network.table_to_markdown">table_to_markdown</a></h2>
<pre><code class="language-sig">network table.table_to_markdown(
    table: 'Option &lt; PathBuf &gt;',
    template: 'Option &lt; String &gt;',
    outfile: 'Option &lt; PathBuf &gt;',
    connections: 'Option &lt; String &gt;'
)
</code></pre>
<h3 id="arguments-105"><a class="header" href="#arguments-105">Arguments</a></h3>
<ul>
<li><code>table: 'Option &lt; PathBuf &gt;'</code> =&gt; Path to the table file</li>
<li><code>template: 'Option &lt; String &gt;'</code> =&gt; String template for table</li>
<li><code>outfile: 'Option &lt; PathBuf &gt;'</code> =&gt; Path to the output file</li>
<li><code>connections: 'Option &lt; String &gt;'</code> =&gt; Show connections column or not</li>
</ul>
<p>Render the Table as a rendered markdown</p>
<h3 id="error-2"><a class="header" href="#error-2">Error</a></h3>
<p>The function will error out if,</p>
<ul>
<li>error reading the table file,</li>
<li>error parsing table template,</li>
<li>neither one of table file or table template is provided,</li>
<li>error while rendering markdown
(caused by error on rendering cell values from templates)</li>
<li>error while writing to the output file</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-7"><a class="header" href="#node-functions-7">Node Functions</a></h1>
<h2 id="node.ts_count"><a class="header" href="#node.ts_count">ts_count</a></h2>
<pre><code class="language-sig">node timeseries.ts_count()
</code></pre>
<h3 id="arguments-106"><a class="header" href="#arguments-106">Arguments</a></h3>
<p>Number of timeseries in the node</p>
<h2 id="node.ts_list"><a class="header" href="#node.ts_list">ts_list</a></h2>
<pre><code class="language-sig">node timeseries.ts_list()
</code></pre>
<h3 id="arguments-107"><a class="header" href="#arguments-107">Arguments</a></h3>
<p>List all timeseries in the node</p>
<h2 id="node.ts_dtype"><a class="header" href="#node.ts_dtype">ts_dtype</a></h2>
<pre><code class="language-sig">node timeseries.ts_dtype(name: '&amp; str', safe: 'bool' = false)
</code></pre>
<h3 id="arguments-108"><a class="header" href="#arguments-108">Arguments</a></h3>
<ul>
<li><code>name: '&amp; str'</code> =&gt; Name of the timeseries</li>
<li><code>safe: 'bool' = false</code> =&gt; Do not error if timeseries does’t exist</li>
</ul>
<p>Type name of the timeseries</p>
<h2 id="node.ts_len"><a class="header" href="#node.ts_len">ts_len</a></h2>
<pre><code class="language-sig">node timeseries.ts_len(name: '&amp; str', safe: 'bool' = false)
</code></pre>
<h3 id="arguments-109"><a class="header" href="#arguments-109">Arguments</a></h3>
<ul>
<li><code>name: '&amp; str'</code> =&gt; Name of the timeseries</li>
<li><code>safe: 'bool' = false</code> =&gt; Do not error if timeseries does’t exist</li>
</ul>
<p>Length of the timeseries</p>
<h2 id="node.ts_print"><a class="header" href="#node.ts_print">ts_print</a></h2>
<pre><code class="language-sig">node timeseries.ts_print(
    name: '&amp; String',
    header: 'bool' = true,
    head: 'Option &lt; i64 &gt;'
)
</code></pre>
<h3 id="arguments-110"><a class="header" href="#arguments-110">Arguments</a></h3>
<ul>
<li><code>name: '&amp; String'</code> =&gt; name of the timeseries</li>
<li><code>header: 'bool' = true</code> =&gt; show header</li>
<li><code>head: 'Option &lt; i64 &gt;'</code> =&gt; number of head rows to show (all by default)</li>
</ul>
<p>Print the given timeseries values in csv format</p>
<h3 id="todo"><a class="header" href="#todo">TODO</a></h3>
<ul>
<li>save to file instead of showing with <code>outfile: Option&lt;PathBuf&gt;</code></li>
</ul>
<h1 id="network-functions-8"><a class="header" href="#network-functions-8">Network Functions</a></h1>
<h2 id="network.ts_print_csv"><a class="header" href="#network.ts_print_csv">ts_print_csv</a></h2>
<pre><code class="language-sig">network timeseries.ts_print_csv(
    name: 'String',
    head: 'Option &lt; usize &gt;',
    nodes: 'Option &lt; HashSet &lt; String &gt; &gt;'
)
</code></pre>
<h3 id="arguments-111"><a class="header" href="#arguments-111">Arguments</a></h3>
<ul>
<li><code>name: 'String'</code> =&gt; Name of the timeseries to save</li>
<li><code>head: 'Option &lt; usize &gt;'</code> =&gt; number of head rows to show (all by default)</li>
<li><code>nodes: 'Option &lt; HashSet &lt; String &gt; &gt;'</code> =&gt; Include only these nodes (all by default)</li>
</ul>
<p>Save timeseries from all nodes into a single csv file</p>
<p>TODO: error/not on unqual length
TODO: error/not on no timeseries, etc…
TODO: output to <code>file: PathBuf</code></p>
<h2 id="network.series_csv"><a class="header" href="#network.series_csv">series_csv</a></h2>
<pre><code class="language-sig">network timeseries.series_csv(
    filter: 'Vec &lt; bool &gt;',
    outfile: 'PathBuf',
    attrs: 'Vec &lt; String &gt;',
    series: 'Vec &lt; String &gt;'
)
</code></pre>
<h3 id="arguments-112"><a class="header" href="#arguments-112">Arguments</a></h3>
<ul>
<li><code>filter: 'Vec &lt; bool &gt;'</code> =&gt;</li>
<li><code>outfile: 'PathBuf'</code> =&gt; Path to the output csv</li>
<li><code>attrs: 'Vec &lt; String &gt;'</code> =&gt; list of attributes to write</li>
<li><code>series: 'Vec &lt; String &gt;'</code> =&gt; list of series to write</li>
</ul>
<p>Write the given nodes to csv with given attributes and series</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-9"><a class="header" href="#network-functions-9">Network Functions</a></h1>
<h2 id="network.set_nodesize_attrs"><a class="header" href="#network.set_nodesize_attrs">set_nodesize_attrs</a></h2>
<pre><code class="language-sig">network visuals.set_nodesize_attrs(
    attrs: '&amp; [f64]',
    minsize: 'f64' = 4.0,
    maxsize: 'f64' = 12.0
)
</code></pre>
<h3 id="arguments-113"><a class="header" href="#arguments-113">Arguments</a></h3>
<ul>
<li><code>attrs: '&amp; [f64]'</code> =&gt; Attribute values to use for size scaling</li>
<li><code>minsize: 'f64' = 4.0</code> =&gt; minimum size of the node</li>
<li><code>maxsize: 'f64' = 12.0</code> =&gt; maximum size of the node</li>
</ul>
<p>Set the node size of the nodes based on the attribute value</p>
<h2 id="network.svg_save"><a class="header" href="#network.svg_save">svg_save</a></h2>
<pre><code class="language-sig">network visuals.svg_save(
    outfile: '&amp; Path',
    label: 'Template' = Template { original: "{_NAME}", parts: [Var("_NAME", "")] },
    x_spacing: 'u64' = 25,
    y_spacing: 'u64' = 25,
    offset: 'u64' = 10,
    twidth: 'f64' = 9.0,
    width: 'u64' = 500,
    height: 'u64' = 240,
    bgcolor: 'Option &lt; String &gt;',
    page_width: 'Option &lt; u64 &gt;',
    page_height: 'Option &lt; u64 &gt;'
)
</code></pre>
<h3 id="arguments-114"><a class="header" href="#arguments-114">Arguments</a></h3>
<ul>
<li><code>outfile: '&amp; Path'</code> =&gt;</li>
<li><code>label: 'Template' = Template { original: "{_NAME}", parts: [Var("_NAME", "")] }</code> =&gt;</li>
<li><code>x_spacing: 'u64' = 25</code> =&gt;</li>
<li><code>y_spacing: 'u64' = 25</code> =&gt;</li>
<li><code>offset: 'u64' = 10</code> =&gt;</li>
<li><code>twidth: 'f64' = 9.0</code> =&gt; in average how many units each text character takes</li>
</ul>
<p>For auto calculating width of the page since we don’t have Cairo</p>
<ul>
<li><code>width: 'u64' = 500</code> =&gt;</li>
<li><code>height: 'u64' = 240</code> =&gt;</li>
<li><code>bgcolor: 'Option &lt; String &gt;'</code> =&gt;</li>
<li><code>page_width: 'Option &lt; u64 &gt;'</code> =&gt;</li>
<li><code>page_height: 'Option &lt; u64 &gt;'</code> =&gt;</li>
</ul>
<p>Exports the network as a svg</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-plugins-1"><a class="header" href="#external-plugins-1">External Plugins</a></h1>
<p>This section showcases the functions from external plugins developed
along side the NADI project due to various reasons.</p>
<p>The plugins listed here can be installed with following steps:</p>
<ul>
<li>clone the repository of external plugins,</li>
<li>compile it locally with cargo,</li>
<li>move all generated dynamic libraries to the nadi plugin directory.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-8"><a class="header" href="#node-functions-8">Node Functions</a></h1>
<h2 id="node.count_node_if"><a class="header" href="#node.count_node_if">count_node_if</a></h2>
<pre><code class="language-sig">node dams.count_node_if(count_attr: '&amp; str', cond: 'bool')
</code></pre>
<h3 id="arguments-115"><a class="header" href="#arguments-115">Arguments</a></h3>
<ul>
<li><code>count_attr: '&amp; str'</code> =&gt;</li>
<li><code>cond: 'bool'</code> =&gt;</li>
</ul>
<p>Count the number of nodes upstream at each point that satisfies a certain condition</p>
<h2 id="node.min_year"><a class="header" href="#node.min_year">min_year</a></h2>
<pre><code class="language-sig">node dams.min_year(yearattr: '&amp; str', write_var: '&amp; str' = "MIN_YEAR")
</code></pre>
<h3 id="arguments-116"><a class="header" href="#arguments-116">Arguments</a></h3>
<ul>
<li><code>yearattr: '&amp; str'</code> =&gt;</li>
<li><code>write_var: '&amp; str' = "MIN_YEAR"</code> =&gt;</li>
</ul>
<p>Propagate the minimum year downstream</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-9"><a class="header" href="#node-functions-9">Node Functions</a></h1>
<h2 id="node.load_csv_fill"><a class="header" href="#node.load_csv_fill">load_csv_fill</a></h2>
<pre><code class="language-sig">node datafill.load_csv_fill(
    name: 'String',
    file: 'Template',
    timefmt: 'String',
    columns: '(String, String)',
    method: 'DataFillMethod' = Linear,
    dtype: 'String' = "Floats"
)
</code></pre>
<h3 id="arguments-117"><a class="header" href="#arguments-117">Arguments</a></h3>
<ul>
<li><code>name: 'String'</code> =&gt; Name of the timeseries</li>
<li><code>file: 'Template'</code> =&gt; Template of the CSV file for the nodes</li>
<li><code>timefmt: 'String'</code> =&gt; date time format, if you only have date, but have time on format string, it will panic</li>
<li><code>columns: '(String, String)'</code> =&gt; Names of date column and value column</li>
<li><code>method: 'DataFillMethod' = Linear</code> =&gt; Method to use for data filling: forward/backward/linear</li>
<li><code>dtype: 'String' = "Floats"</code> =&gt; DataType to load into timeseries</li>
</ul>
<h2 id="node.datafill_experiment"><a class="header" href="#node.datafill_experiment">datafill_experiment</a></h2>
<pre><code class="language-sig">node datafill.datafill_experiment(
    name: 'String',
    file: 'Template',
    ratio_var: 'String',
    columns: 'Option &lt; (String, String) &gt;',
    experiments: 'usize' = 10,
    samples: 'usize' = 100
)
</code></pre>
<h3 id="arguments-118"><a class="header" href="#arguments-118">Arguments</a></h3>
<ul>
<li><code>name: 'String'</code> =&gt; Prefix for name of the series to save metrics on</li>
<li><code>file: 'Template'</code> =&gt; Template of the CSV file for the nodes</li>
<li><code>ratio_var: 'String'</code> =&gt; Variable to use for inputratio/outputratio methods</li>
<li><code>columns: 'Option &lt; (String, String) &gt;'</code> =&gt; Names of date column and value column</li>
<li><code>experiments: 'usize' = 10</code> =&gt; Number of experiements to run</li>
<li><code>samples: 'usize' = 100</code> =&gt; Number of samples on each experiment</li>
</ul>
<h1 id="network-functions-10"><a class="header" href="#network-functions-10">Network Functions</a></h1>
<h2 id="network.save_experiments_csv"><a class="header" href="#network.save_experiments_csv">save_experiments_csv</a></h2>
<pre><code class="language-sig">network datafill.save_experiments_csv(
    outfile: 'PathBuf',
    attrs: 'Vec &lt; String &gt;',
    prefix: 'String',
    errors: 'Vec &lt; String &gt;',
    filter: 'Option &lt; Vec &lt; bool &gt; &gt;'
)
</code></pre>
<h3 id="arguments-119"><a class="header" href="#arguments-119">Arguments</a></h3>
<ul>
<li><code>outfile: 'PathBuf'</code> =&gt; Path to the output csv</li>
<li><code>attrs: 'Vec &lt; String &gt;'</code> =&gt; list of attributes to write</li>
<li><code>prefix: 'String'</code> =&gt; Prefix</li>
<li><code>errors: 'Vec &lt; String &gt;'</code> =&gt; list of errors to write</li>
<li><code>filter: 'Option &lt; Vec &lt; bool &gt; &gt;'</code> =&gt;</li>
</ul>
<p>Write the given nodes to csv with given attributes and experiment results</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-10"><a class="header" href="#node-functions-10">Node Functions</a></h1>
<h2 id="node.calc_ts_error"><a class="header" href="#node.calc_ts_error">calc_ts_error</a></h2>
<pre><code class="language-sig">node errors.calc_ts_error(
    ts1: '&amp; str',
    ts2: '&amp; str',
    error: '&amp; str' = "rmse"
)
</code></pre>
<h3 id="arguments-120"><a class="header" href="#arguments-120">Arguments</a></h3>
<ul>
<li><code>ts1: '&amp; str'</code> =&gt; Timeseries value to use as actual value</li>
<li><code>ts2: '&amp; str'</code> =&gt; Timeseries value to be used to calculate the error</li>
<li><code>error: '&amp; str' = "rmse"</code> =&gt; Error type, one of rmse/nrmse/abserr/nse</li>
</ul>
<p>Calculate Error from two timeseries values in the node</p>
<p>It calculates the error between two timeseries values from the node</p>
<h2 id="node.calc_ts_errors"><a class="header" href="#node.calc_ts_errors">calc_ts_errors</a></h2>
<pre><code class="language-sig">node errors.calc_ts_errors(
    ts1: '&amp; String',
    ts2: '&amp; String',
    errors: '&amp; [String]'
)
</code></pre>
<h3 id="arguments-121"><a class="header" href="#arguments-121">Arguments</a></h3>
<ul>
<li><code>ts1: '&amp; String'</code> =&gt; Timeseries value to use as actual value</li>
<li><code>ts2: '&amp; String'</code> =&gt; Timeseries value to be used to calculate the error</li>
<li><code>errors: '&amp; [String]'</code> =&gt; Error types to calculate, one of rmse/nrmse/abserr/nse</li>
</ul>
<p>Calculate Error from two timeseries values in the node</p>
<p>It calculates the error between two timeseries values from the node.</p>
<h1 id="network-functions-11"><a class="header" href="#network-functions-11">Network Functions</a></h1>
<h2 id="network.calc_attr_error"><a class="header" href="#network.calc_attr_error">calc_attr_error</a></h2>
<pre><code class="language-sig">network errors.calc_attr_error(
    attr1: 'String',
    attr2: 'String',
    error: 'String' = "rmse"
)
</code></pre>
<h3 id="arguments-122"><a class="header" href="#arguments-122">Arguments</a></h3>
<ul>
<li><code>attr1: 'String'</code> =&gt; Attribute value to use as actual value</li>
<li><code>attr2: 'String'</code> =&gt; Attribute value to be used to calculate the error</li>
<li><code>error: 'String' = "rmse"</code> =&gt; Error type, one of rmse/nrmse/abserr/nse</li>
</ul>
<p>Calculate Error from two attribute values in the network</p>
<p>It calculates the error using two attribute values from all the nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-12"><a class="header" href="#network-functions-12">Network Functions</a></h1>
<h2 id="network.fancy_print"><a class="header" href="#network.fancy_print">fancy_print</a></h2>
<pre><code class="language-sig">network fancy_print.fancy_print()
</code></pre>
<h3 id="arguments-123"><a class="header" href="#arguments-123">Arguments</a></h3>
<p>Fancy print a network</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-13"><a class="header" href="#network-functions-13">Network Functions</a></h1>
<h2 id="network.plot_timeseries"><a class="header" href="#network.plot_timeseries">plot_timeseries</a></h2>
<pre><code class="language-sig">network gnuplot.plot_timeseries(
    csvfile: 'Template',
    datecol: '&amp; str',
    datacol: '&amp; str',
    outfile: '&amp; Path',
    timefmt: '&amp; str' = "%Y-%m-%d",
    config: '&amp; GnuplotConfig' = GnuplotConfig { outfile: None, terminal: None, csv: false, preamble: "" },
    skip_missing: 'bool' = false
)
</code></pre>
<h3 id="arguments-124"><a class="header" href="#arguments-124">Arguments</a></h3>
<ul>
<li><code>csvfile: 'Template'</code> =&gt;</li>
<li><code>datecol: '&amp; str'</code> =&gt;</li>
<li><code>datacol: '&amp; str'</code> =&gt;</li>
<li><code>outfile: '&amp; Path'</code> =&gt;</li>
<li><code>timefmt: '&amp; str' = "%Y-%m-%d"</code> =&gt;</li>
<li><code>config: '&amp; GnuplotConfig' = GnuplotConfig { outfile: None, terminal: None, csv: false, preamble: "" }</code> =&gt;</li>
<li><code>skip_missing: 'bool' = false</code> =&gt;</li>
</ul>
<p>Generate a gnuplot file that plots the timeseries data in the network</p>
<div style="break-before: page; page-break-before: always;"></div><div class="warning">
This plugin uses cairo to draw graphics, so far it has only been tested on Linux, but this should also work on Mac. Compiling it in windows might need additional steps that are not documented here.
</div>
<h1 id="node-functions-11"><a class="header" href="#node-functions-11">Node Functions</a></h1>
<h2 id="node.attr_fraction_svg"><a class="header" href="#node.attr_fraction_svg">attr_fraction_svg</a></h2>
<pre><code class="language-sig">node graphics.attr_fraction_svg(
    attr: '&amp; str',
    outfile: '&amp; Template',
    color: '&amp; AttrColor',
    height: 'f64' = 80.0,
    width: 'f64' = 80.0,
    margin: 'f64' = 10.0
)
</code></pre>
<h3 id="arguments-125"><a class="header" href="#arguments-125">Arguments</a></h3>
<ul>
<li><code>attr: '&amp; str'</code> =&gt;</li>
<li><code>outfile: '&amp; Template'</code> =&gt;</li>
<li><code>color: '&amp; AttrColor'</code> =&gt;</li>
<li><code>height: 'f64' = 80.0</code> =&gt;</li>
<li><code>width: 'f64' = 80.0</code> =&gt;</li>
<li><code>margin: 'f64' = 10.0</code> =&gt;</li>
</ul>
<p>Create a SVG file with the given network structure</p>
<h1 id="network-functions-14"><a class="header" href="#network-functions-14">Network Functions</a></h1>
<h2 id="network.csv_load_ts"><a class="header" href="#network.csv_load_ts">csv_load_ts</a></h2>
<pre><code class="language-sig">network graphics.csv_load_ts(
    file: 'PathBuf',
    name: 'String',
    date_col: 'String' = "date",
    timefmt: 'String' = "%Y-%m-%d",
    data_type: 'String' = "Floats"
)
</code></pre>
<h3 id="arguments-126"><a class="header" href="#arguments-126">Arguments</a></h3>
<ul>
<li><code>file: 'PathBuf'</code> =&gt;</li>
<li><code>name: 'String'</code> =&gt;</li>
<li><code>date_col: 'String' = "date"</code> =&gt;</li>
<li><code>timefmt: 'String' = "%Y-%m-%d"</code> =&gt;</li>
<li><code>data_type: 'String' = "Floats"</code> =&gt;</li>
</ul>
<p>Count the number of na values in CSV file for each nodes in a network</p>
<h3 id="arguments-127"><a class="header" href="#arguments-127">Arguments</a></h3>
<ul>
<li><code>file</code>: Input CSV file path to read (should have column with
node names for all nodes)</li>
<li><code>name</code>: Name of the timeseries</li>
<li><code>date_col</code>: Date Column name</li>
<li><code>timefmt</code>: date time format, if you only have date, but have time on format string, it will panic</li>
<li><code>data_type</code>: Type of the data to cast into</li>
</ul>
<h2 id="network.csv_count_na"><a class="header" href="#network.csv_count_na">csv_count_na</a></h2>
<pre><code class="language-sig">network graphics.csv_count_na(
    file: 'PathBuf',
    outattr: 'Option &lt; String &gt;',
    sort: 'bool' = false,
    skip_zero: 'bool' = false,
    head: 'Option &lt; i64 &gt;'
)
</code></pre>
<h3 id="arguments-128"><a class="header" href="#arguments-128">Arguments</a></h3>
<ul>
<li><code>file: 'PathBuf'</code> =&gt;</li>
<li><code>outattr: 'Option &lt; String &gt;'</code> =&gt;</li>
<li><code>sort: 'bool' = false</code> =&gt;</li>
<li><code>skip_zero: 'bool' = false</code> =&gt;</li>
<li><code>head: 'Option &lt; i64 &gt;'</code> =&gt;</li>
</ul>
<p>Count the number of na values in CSV file for each nodes in a network</p>
<h3 id="arguments-129"><a class="header" href="#arguments-129">Arguments</a></h3>
<ul>
<li><code>file</code>: Input CSV file path to read (should have column with node names for all nodes)</li>
<li><code>outattr</code>: Output attribute to save the count of NA to. If empty print to stdout</li>
<li><code>sort</code>: show the nodes with larger gaps on top, only applicable while printing</li>
<li><code>head</code>: at max show only this number of nodes</li>
<li><code>skip_zero</code>: skip nodes with zero missing numbers</li>
</ul>
<h2 id="network.csv_data_blocks_svg"><a class="header" href="#network.csv_data_blocks_svg">csv_data_blocks_svg</a></h2>
<pre><code class="language-sig">network graphics.csv_data_blocks_svg(
    csvfile: 'PathBuf',
    outfile: 'PathBuf',
    label: 'Template',
    date_col: 'String' = "date",
    config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } },
    blocks_width: 'f64' = 500.0,
    fit: 'bool' = false
)
</code></pre>
<h3 id="arguments-130"><a class="header" href="#arguments-130">Arguments</a></h3>
<ul>
<li><code>csvfile: 'PathBuf'</code> =&gt;</li>
<li><code>outfile: 'PathBuf'</code> =&gt;</li>
<li><code>label: 'Template'</code> =&gt;</li>
<li><code>date_col: 'String' = "date"</code> =&gt;</li>
<li><code>config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } }</code> =&gt;</li>
<li><code>blocks_width: 'f64' = 500.0</code> =&gt;</li>
<li><code>fit: 'bool' = false</code> =&gt;</li>
</ul>
<p>Draw the data blocks with arrows in timeline</p>
<h2 id="network.export_svg"><a class="header" href="#network.export_svg">export_svg</a></h2>
<pre><code class="language-sig">network graphics.export_svg(
    outfile: 'PathBuf',
    config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } },
    fit: 'bool' = false,
    label: 'Option &lt; Template &gt;',
    highlight: '&amp; [usize]' = []
)
</code></pre>
<h3 id="arguments-131"><a class="header" href="#arguments-131">Arguments</a></h3>
<ul>
<li><code>outfile: 'PathBuf'</code> =&gt;</li>
<li><code>config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } }</code> =&gt;</li>
<li><code>fit: 'bool' = false</code> =&gt;</li>
<li><code>label: 'Option &lt; Template &gt;'</code> =&gt;</li>
<li><code>highlight: '&amp; [usize]' = []</code> =&gt;</li>
</ul>
<p>Create a SVG file with the given network structure</p>
<h2 id="network.table_to_svg"><a class="header" href="#network.table_to_svg">table_to_svg</a></h2>
<pre><code class="language-sig">network graphics.table_to_svg(
    outfile: 'PathBuf',
    table: 'Option &lt; PathBuf &gt;',
    template: 'Option &lt; String &gt;',
    config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } },
    fit: 'bool' = false,
    highlight: '&amp; [String]' = []
)
</code></pre>
<h3 id="arguments-132"><a class="header" href="#arguments-132">Arguments</a></h3>
<ul>
<li><code>outfile: 'PathBuf'</code> =&gt;</li>
<li><code>table: 'Option &lt; PathBuf &gt;'</code> =&gt;</li>
<li><code>template: 'Option &lt; String &gt;'</code> =&gt;</li>
<li><code>config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } }</code> =&gt;</li>
<li><code>fit: 'bool' = false</code> =&gt;</li>
<li><code>highlight: '&amp; [String]' = []</code> =&gt;</li>
</ul>
<p>Create a SVG file with the given network structure</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-15"><a class="header" href="#network-functions-15">Network Functions</a></h1>
<h2 id="network.save_graphviz"><a class="header" href="#network.save_graphviz">save_graphviz</a></h2>
<pre><code class="language-sig">network graphviz.save_graphviz(
    outfile: '&amp; Path',
    name: '&amp; str' = "network",
    global_attrs: '&amp; str' = "",
    node_attr: 'Option &lt; &amp; Template &gt;',
    edge_attr: 'Option &lt; &amp; Template &gt;'
)
</code></pre>
<h3 id="arguments-133"><a class="header" href="#arguments-133">Arguments</a></h3>
<ul>
<li><code>outfile: '&amp; Path'</code> =&gt;</li>
<li><code>name: '&amp; str' = "network"</code> =&gt;</li>
<li><code>global_attrs: '&amp; str' = ""</code> =&gt;</li>
<li><code>node_attr: 'Option &lt; &amp; Template &gt;'</code> =&gt;</li>
<li><code>edge_attr: 'Option &lt; &amp; Template &gt;'</code> =&gt;</li>
</ul>
<p>Save the network as a graphviz file</p>
<h3 id="arguments-134"><a class="header" href="#arguments-134">Arguments:</a></h3>
<ul>
<li><code>outfile</code> - Path to the output file</li>
<li><code>name</code> - Name of the graph</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-16"><a class="header" href="#network-functions-16">Network Functions</a></h1>
<h2 id="network.export_map"><a class="header" href="#network.export_map">export_map</a></h2>
<pre><code class="language-sig">network html.export_map(
    outfile: '&amp; Path',
    template: 'Template',
    pagetitle: '&amp; str' = "NADI Network",
    nodetitle: 'Template' = Template { original: "{_NAME}", parts: [Var("_NAME", "")] },
    connections: 'bool' = true
)
</code></pre>
<h3 id="arguments-135"><a class="header" href="#arguments-135">Arguments</a></h3>
<ul>
<li><code>outfile: '&amp; Path'</code> =&gt;</li>
<li><code>template: 'Template'</code> =&gt;</li>
<li><code>pagetitle: '&amp; str' = "NADI Network"</code> =&gt;</li>
<li><code>nodetitle: 'Template' = Template { original: "{_NAME}", parts: [Var("_NAME", "")] }</code> =&gt;</li>
<li><code>connections: 'bool' = true</code> =&gt;</li>
</ul>
<p>Exports the network as a HTML map</p>
<div style="break-before: page; page-break-before: always;"></div><div class="warning">
This plugin uses gdal to read/write GIS files, it can be compiled easily in Linux and Mac by installing gdal as a prerequisite, but on windows that step might be complicated. Please refer to the documentation of gdal to know how to install it in windows. Or use the provided dlls from the plugin repo.
</div>
<h1 id="network-functions-17"><a class="header" href="#network-functions-17">Network Functions</a></h1>
<h2 id="network.gis_load_network"><a class="header" href="#network.gis_load_network">gis_load_network</a></h2>
<pre><code class="language-sig">network gis.gis_load_network(
    file: 'PathBuf',
    source: 'String',
    destination: 'String',
    layer: 'Option &lt; String &gt;',
    ignore_null: 'bool' = false
)
</code></pre>
<h3 id="arguments-136"><a class="header" href="#arguments-136">Arguments</a></h3>
<ul>
<li><code>file: 'PathBuf'</code> =&gt; GIS file to load (can be any format GDAL can understand)</li>
<li><code>source: 'String'</code> =&gt; Field in the GIS file corresponding to the input node name</li>
<li><code>destination: 'String'</code> =&gt; layer of the GIS file corresponding to the output node name</li>
<li><code>layer: 'Option &lt; String &gt;'</code> =&gt; layer of the GIS file, first one picked by default</li>
<li><code>ignore_null: 'bool' = false</code> =&gt; Ignore feature if it has fields with null value</li>
</ul>
<p>Load network from a GIS file</p>
<p>Loads the network from a gis file containing the edges in fields</p>
<h2 id="network.gis_load_attrs"><a class="header" href="#network.gis_load_attrs">gis_load_attrs</a></h2>
<pre><code class="language-sig">network gis.gis_load_attrs(
    file: 'PathBuf',
    node: 'String',
    layer: 'Option &lt; String &gt;',
    geometry: 'String' = "GEOM",
    ignore: 'String' = "",
    sanitize: 'bool' = true,
    err_no_node: 'bool' = false
)
</code></pre>
<h3 id="arguments-137"><a class="header" href="#arguments-137">Arguments</a></h3>
<ul>
<li><code>file: 'PathBuf'</code> =&gt; GIS file to load (can be any format GDAL can understand)</li>
<li><code>node: 'String'</code> =&gt; Field in the GIS file corresponding to node name</li>
<li><code>layer: 'Option &lt; String &gt;'</code> =&gt; layer of the GIS file, first one picked by default</li>
<li><code>geometry: 'String' = "GEOM"</code> =&gt; Attribute to save the GIS geometry in</li>
<li><code>ignore: 'String' = ""</code> =&gt; Field names separated by comma, to ignore</li>
<li><code>sanitize: 'bool' = true</code> =&gt; sanitize the name of the fields</li>
<li><code>err_no_node: 'bool' = false</code> =&gt; Error if all nodes are not found in the GIS file</li>
</ul>
<p>Load node attributes from a GIS file</p>
<p>The function reads a GIS file in any format (CSV, GPKG, SHP,
JSON, etc) and loads their fields as attributes to the nodes.</p>
<h2 id="network.gis_save_connections"><a class="header" href="#network.gis_save_connections">gis_save_connections</a></h2>
<pre><code class="language-sig">network gis.gis_save_connections(
    file: 'PathBuf',
    geometry: 'String',
    driver: 'Option &lt; String &gt;',
    layer: 'String' = "network",
    filter: 'Option &lt; Vec &lt; bool &gt; &gt;'
)
</code></pre>
<h3 id="arguments-138"><a class="header" href="#arguments-138">Arguments</a></h3>
<ul>
<li><code>file: 'PathBuf'</code> =&gt;</li>
<li><code>geometry: 'String'</code> =&gt;</li>
<li><code>driver: 'Option &lt; String &gt;'</code> =&gt;</li>
<li><code>layer: 'String' = "network"</code> =&gt;</li>
<li><code>filter: 'Option &lt; Vec &lt; bool &gt; &gt;'</code> =&gt;</li>
</ul>
<p>Save GIS file of the connections</p>
<h2 id="network.gis_save_nodes"><a class="header" href="#network.gis_save_nodes">gis_save_nodes</a></h2>
<pre><code class="language-sig">network gis.gis_save_nodes(
    file: 'PathBuf',
    geometry: 'String',
    attrs: 'HashMap &lt; String, String &gt;' = {},
    driver: 'Option &lt; String &gt;',
    layer: 'String' = "nodes",
    filter: 'Option &lt; Vec &lt; bool &gt; &gt;'
)
</code></pre>
<h3 id="arguments-139"><a class="header" href="#arguments-139">Arguments</a></h3>
<ul>
<li><code>file: 'PathBuf'</code> =&gt;</li>
<li><code>geometry: 'String'</code> =&gt;</li>
<li><code>attrs: 'HashMap &lt; String, String &gt;' = {}</code> =&gt;</li>
<li><code>driver: 'Option &lt; String &gt;'</code> =&gt;</li>
<li><code>layer: 'String' = "nodes"</code> =&gt;</li>
<li><code>filter: 'Option &lt; Vec &lt; bool &gt; &gt;'</code> =&gt;</li>
</ul>
<p>Save GIS file of the nodes</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-12"><a class="header" href="#node-functions-12">Node Functions</a></h1>
<h2 id="node.print_node"><a class="header" href="#node.print_node">print_node</a></h2>
<pre><code class="language-sig">node print_node.print_node()
</code></pre>
<h3 id="arguments-140"><a class="header" href="#arguments-140">Arguments</a></h3>
<p>Print the node with its inputs and outputs</p>
<h1 id="network-functions-18"><a class="header" href="#network-functions-18">Network Functions</a></h1>
<h2 id="network.print_attr_csv"><a class="header" href="#network.print_attr_csv">print_attr_csv</a></h2>
<pre><code class="language-sig">network print_node.print_attr_csv(*args)
</code></pre>
<h3 id="arguments-141"><a class="header" href="#arguments-141">Arguments</a></h3>
<ul>
<li><code>*args</code> =&gt;</li>
</ul>
<p>Print the given attributes in csv format with first column with node name</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-13"><a class="header" href="#node-functions-13">Node Functions</a></h1>
<h2 id="node.check_negative"><a class="header" href="#node.check_negative">check_negative</a></h2>
<pre><code class="language-sig">node streamflow.check_negative(ts_name: '&amp; str')
</code></pre>
<h3 id="arguments-142"><a class="header" href="#arguments-142">Arguments</a></h3>
<ul>
<li><code>ts_name: '&amp; str'</code> =&gt; Name of the timeseries with streamflow data</li>
</ul>
<p>Check the given streamflow timeseries for negative values</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structure"><a class="header" href="#data-structure">Data Structure</a></h1>
<p>This section will describe the data structures associated with NADI system in brief.</p>
<p>For more accurate and upto date details on the data structures and their available methods. Look at the API reference of <a href="https://docs.rs/nadi_core/latest/nadi_core/"><code>nadi_core</code> on docs.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-1"><a class="header" href="#node-1">Node</a></h1>
<p>Points with attributes and timeseries. These can be any point as long
as they’ll be on the network and connection to each other.</p>
<p>The attributes can be any format. There is a special type of attribute
timeseries to deal with timeseries data that has been provided by the
system. But users are free to make their own attributes and plugins +
functions that can work with those attributes.</p>
<p>Since attributes are loaded using TOML file, simple attributes can be
stored and parsed from strings, moderately complex ones can be saved
as a combination of array and tables, and more complex ones can be
saved in different files and their path can be stored as node
attributes.</p>
<p>Here is an example node attribute file. Here we have string, float, int and boolean values, as well as a example csv timeseries</p>
<pre><code class="language-toml">stn="smithland"
nat_7q10=12335.94850131619
orsanco_7q10=16900
lock=true

[ts.csv]
streamflow = {path="data/smithland.csv", datetime="date", data="flow"}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-1"><a class="header" href="#network-1">Network</a></h1>
<p>Collection of Nodes, with Connection information. The connection
information is saved in the nodes itself (=inputs= and =output=
variables), but they are assigned from the network.</p>
<p>The nadi system (lit, river system), is designed for the connections
between points along a river. Out of different types of river networks
possible, it can only handle non-branching tributaries system, where
each point can have zero to multiple inputs, but can only have one
output. Overall the system should have a single output point. There
can be branches in the river itself in the physical sense as long as
they converse before the next point of interests. There cannot be node
points that have more than one path to reach another node in the
representative system.</p>
<p>Network file are simple text files with each edge on one line. Node
names can be words with alphanumeric characters with the additional
character <code>_</code>, similar to how rust identifiers work. The Node names
can also be quoted strings, in those cases any characters are
supported inside the quotes.</p>
<p>Here is an example network file,</p>
<pre><code class="language-network">cannelton -&gt; newburgh
newburgh -&gt; evansville
evansville -&gt; "jt-myers"
# comments are supported
"jt-myers" -&gt; "old-shawneetown"
"old-shawneetown" -&gt; golconda
markland -&gt; mcalpine
golconda -&gt; smithland
</code></pre>
<p>Drawing it out:</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>network svg_save(
   "./output/mississippi.svg",
	label="[{INDEX}] {_NAME:repl(-, ):case(title)}"
)
<span class="boring">network clip()
</span><span class="boring"># the link path needs to be relative to this file
</span><span class="boring">network echo("../output/mississippi.svg")
</span></code></pre>
<p>Results:</p>
<center>  
<p><img src="devref/../output/mississippi.sv" alt="" /></p>
</center>  
<p>The program also plans to support the connection import from the <a href="https://graphviz.org/doc/info/lang.html">DOT
format (graphviz package)</a>.</p>
<p>Network file without any connection format can
be written as a node per line, but those network can only call
sequential functions, and not input dependent ones.</p>
<p>Depending on the use cases, it can probably be applied to other
systems that are similar to a river system. Or even without the
connection information, the functions that are independent to each
other can be run in sequential order.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timeseries"><a class="header" href="#timeseries">Timeseries</a></h1>
<p>Timeseries of values, at regular interval. Can support integers,
floats, booleans, strings, Arrays and Tables.</p>
<p>For timeseries that are not in a format that NADI can understand. The
path to the timeseries can be provided as a node attribute and plugin
functions can be written to use that path to load the timeseries for
the node.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-templates-1"><a class="header" href="#string-templates-1">String Templates</a></h1>
<p>The templating system will be used by an external library developed by
me. The library can be modified if there are specific needs for this
project.</p>
<p>The template system is feature rich, allowing for formatting, simple
string transformations, and airthmatic calculations based on the
variables (node attributes in this case). This can be used to generate
file paths, and similar strings based on node attributes, as well as
to format the cell values for exported table, figures, etc.</p>
<p>The template library is also available for <code>Rust</code>, <code>C</code> and <code>C++</code>, but
all the interactions with the templates will be done through the
<code>nadi</code> interface, so that is not required.</p>
<p>Documentations on the template system, can be redirected to
<a href="https://docs.rs/string-template-plus/latest/string_template_plus/">the <code>string_template_plus</code> library page</a>.</p>
<p>Brief explanation on the template system is given below.</p>
<h2 id="template-parts"><a class="header" href="#template-parts">Template Parts</a></h2>
<p>Templates have variables, time formats, expressions, and commands (disabled by default);</p>
<pre><code class="language-stp">Hi, my name is {name}, my address is {address?"N/A"}.
Current time is {%H} hour  {%M} minutes.
</code></pre>
<p>Results (with:  name=John; address=123 Road, USA):</p>
<pre><code class="language-output">Hi, my name is John, my address is 123 Road, USA.
Current time is 23 hour  36 minutes.
</code></pre>
<h2 id="optional-variables"><a class="header" href="#optional-variables">Optional Variables</a></h2>
<p>Variables can be chained in an optional way, so the first one that’s
found will be used (e.g. <code>{nickname?name}</code> will render nickname if
it’s present, else name);</p>
<pre><code class="language-stp">Hi, I am {nickname?name}, my address is {address?"N/A"}.
</code></pre>
<p>Results (with:  name=John; nickname=J; address=123 Road, USA):</p>
<pre><code class="language-output">Hi, I am J, my address is 123 Road, USA.
</code></pre>
<h2 id="string-literal"><a class="header" href="#string-literal">String Literal</a></h2>
<p>Variables when replaced with literal strings (quoted strings), they
will be used directly <code>{address?"N/A"}</code> will render <code>N/A</code> is
<code>address</code> is not present;</p>
<pre><code class="language-stp">Hi, I am {nickname?name}, my address is {address?"N/A"}.
</code></pre>
<p>Results (with:  name=John):</p>
<pre><code class="language-output">Hi, I am John, my address is N/A.
</code></pre>
<h2 id="transformers"><a class="header" href="#transformers">Transformers</a></h2>
<p>Variables can have optional transformers which transform the string
based on their rules, (e.g. float transformer will truncate the
float, upcase will make the string UPPERCASE, etc.);</p>
<pre><code class="language-stp">Hi, I am {nickname?name:case(up)}, my address is {address?"N/A"}.
</code></pre>
<p>Results (with:  name=Joe):</p>
<pre><code class="language-output">Hi, I am JOE, my address is N/A.
</code></pre>
<h2 id="time-formats"><a class="header" href="#time-formats">Time formats</a></h2>
<p>time formats are formatted current time (e.g. <code>{%Y}</code> will become
<code>2024</code> as of now);</p>
<pre><code class="language-stp">Today is {%B %d} of the year {%Y}.
</code></pre>
<p>Results (with:  name=John):</p>
<pre><code class="language-output">Today is July 02 of the year 2025.
</code></pre>
<h2 id="lisp-expressions"><a class="header" href="#lisp-expressions">Lisp Expressions</a></h2>
<p>expressions are lisp expressions that will be evaluated and the
results will be used. The lisp expression can also access any
variables and do any supported programming. (e.g. <code>(+ 1 1)</code> in lisp
will become <code>2</code>);</p>
<pre><code class="language-stp">guess my age(x) if: (x + 21) * 4 = =(* (+ (st+num 'age) 21) 4).
</code></pre>
<p>Results (with:  age=20):</p>
<pre><code class="language-output">guess my age(x) if: (x + 21) * 4 = 164.
</code></pre>
<h2 id="nadi-specific-options"><a class="header" href="#nadi-specific-options">NADI Specific options</a></h2>
<p>Besides the above points, specific to nadi system, any node template
will have all the variables from node attributes available as strings
for template. For string variables, their name can be used to access
quoted string format, while their name with underscore prefix will be
unquoted raw string. (e.g. if we have attribute <code>name="smithland"</code>,
then <code>{name}</code> will render to <code>"smithland"</code>, while <code>{_name}</code> will
render to <code>smithland</code>).</p>
<p>Nadi system uses templates in a variety of place, and plugin functions
also sometimes take templates for file path, or strings, and such
things. Look at the help string of the function to see if it takes
<code>String</code> or <code>Template</code> type.</p>
<p>For example <code>render</code> is a function that takes a template and prints it
after rendering it for each node.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span><span class="boring">node[ohio] set_attrs(river="the Ohio River", streamflow=45334.12424343)
</span>node[ohio,red] render(
	"(=(+ 1 (st+num 'INDEX))th node) {_NAME:case(title)}
	River Flow = {streamflow:calc(/10000):f(3)?\"NA\"} x 10^4"
)
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  red = "(5th node) Red\n\tRiver Flow = NA x 10^4",
  ohio = "(6th node) Ohio\n\tRiver Flow = 4.533 x 10^4"
}
</code></pre>
<p>As seen in above example, you can render variables, transform them, use basic calculations.</p>
<p>Or you can use <code>lisp</code> syntax to do more complex calculations. Refer to
<a href="devref/../system/extensions.html">Nadi Extension Capabilities</a> section for more
info on how to use <code>lisp</code> on string template.</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span><span class="boring">node[ohio] set_attrs(river="the Ohio River", streamflow=45334.12424343)
</span>node[ohio] render(
	"{_river:case(title)} Streamflow
	from lisp = {=(/ (st+num 'streamflow) 1000):f(2)} x 10^3 cfs"
)
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  ohio = "The Ohio River Streamflow\n\tfrom lisp = 45.33 x 10^3 cfs"
}
</code></pre>
<h2 id="some-complex-examples"><a class="header" href="#some-complex-examples">Some Complex Examples</a></h2>
<p>Optional variables and a command; note that commands can have variables inside them:</p>
<pre><code class="language-stp">hi there, this {is?a?"test"} for $(echo a simple case {that?} {might} be "possible")
</code></pre>
<p>Results (with:  might=may):</p>
<pre><code class="language-output">hi there, this test for $(echo a simple case  may be possible)
</code></pre>
<p>Optional variables with transformers inside command.</p>
<pre><code class="language-stp">Hi {like?a?"test"} for $(this does {work:case(up)} now) (yay)
</code></pre>
<p>Results (with:  work=Fantastic Job):</p>
<pre><code class="language-output">Hi test for $(this does FANTASTIC JOB now) (yay)
</code></pre>
<p>If you need to use <code>{</code> and <code>}</code> in a template, you can escape them. Following template shows how LaTeX commands can be generated from templates.</p>
<pre><code class="language-stp">more {formatting?} options on {%F} and
\\latex\{command\}\{with {variable}\}, should work.
</code></pre>
<p>Results (with:  command=Error;variable=Var):</p>
<pre><code class="language-output">more  options on 2025-07-02 and
\latex{command}{with Var}, should work.
</code></pre>
<p>This just combined a lot of different things from above:</p>
<pre><code class="language-stp">let's try {every:f(2)?and?"everything"}
for $(a complex case {that?%F?} {might?be?not?found} be "possible")

see $(some-command --flag "and the value" {problem})
=(+ 1 2 (st+num 'hithere) (st+num "otherhi"))
{otherhi?=(1+ pi):f(4)}
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">None of the variables ["might", "be", "not", "found"] found
</code></pre>
<p>This shows the error for the first template part that errors out, even
if <code>{problem}</code> will also error later, so while solving for problems in
string templates, you might have to give it multiple tries.</p>
<h2 id="advanced-string-template-with-lisp"><a class="header" href="#advanced-string-template-with-lisp">Advanced String Template with LISP</a></h2>
<p>Nadi Template string is useful when you want to represent node
specific string, or file path in a network. This is not as advanced as
the formatted strings in python. But it can be used for complex
situations based on the current functionality.</p>
<p>The most important extension capability of the string template is the
embedded lisp system.</p>
<p>As we know, templates can render variables, and have some capacity of transforming them:</p>
<pre><code class="language-stp">{name:case(title):repl(-, )} River Streamflow = {streamflow} cfs
</code></pre>
<p>Results (with:  name=Ohio; streamflow=12000):</p>
<pre><code class="language-output">Ohio River Streamflow = 12000 cfs
</code></pre>
<p>But for numerical operation, the transformers capabilities are limited as they are made for strings.</p>
<p>With lisp, we can add more logic to our templates.</p>
<pre><code class="language-stp">{name:case(title):repl(-, )} River Streamflow is =(
	if (&gt; (st+num 'streamflow) 10000)
	'Higher 'Lower
) than the threshold of 10^5 cfs.
</code></pre>
<p>Results (with:  name=Ohio; streamflow=12000):</p>
<pre><code class="language-output">Ohio River Streamflow is Higher than the threshold of 10^5 cfs.
</code></pre>
<p>The available lisp functions are also limited, but the syntax itself
gives us better airthmetic and logical calculations.</p>
<h1 id="note"><a class="header" href="#note">Note</a></h1>
<p>As the template string can get complicated, and the parsing is done
through <code>Regex</code>, it is not perfect. If you come across any parsing
problems, please raise an issue at <a href="https://github.com/Atreyagaurav/string-template-plus">string template
plus</a> github
repo.</p>
<h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Note that running commands within the templates is disabled for
now.</p>
<pre><code class="language-stp">echo today=$(date +%Y-%m-%d) {%Y-%m-%d}
</code></pre>
<p>Results (with: ):</p>
<pre><code class="language-output">echo today=$(date +%Y-%m-%d) 2025-07-02
</code></pre>
<p>But if you are writing a command template to run in bash, then
it’ll be executed as the syntax is similar.</p>
<pre><code class="language-task">network command("echo today=$(date +%Y-%m-%d) {%Y-%m-%d}")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">$ echo today=$(date +%Y-%m-%d) 2025-07-02
</code></pre>
<p>Here although the <code>$(date +%Y-%m-%d)</code> portion was not rendered on template rendering process, the command was still valid, and was executed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tables"><a class="header" href="#tables">Tables</a></h1>
<p>Tables are data types with headers and the value template. Tables can
be rendered/exported into CSV, JSON, and LaTeX format. Other formats
can be added later. Although tables are not exposed to the plugin
system, functions to export different table formats can be written as
a network function.</p>
<p>A sample Table file showing two columns, left aligned name for station
in title case, and right aligned columns for latitude and longitude
with float value of 4 digits after decimal:</p>
<pre><code class="language-table"><span class="boring">network load_file("./data/mississippi.net")
</span>&lt;Name =&gt; {_NAME:repl(-, ):case(title)}
^Ind =&gt; =(+ (st+num 'INDEX) 1)
&gt;Order =&gt; {ORDER}
^Level =&gt; {LEVEL}
# something is wrong with the set_level algorithm
# Ohio - tenessee should be level 1, and missouri/yellowstone should be 0
</code></pre>
<p>Results:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Ind</th><th style="text-align: right">Order</th><th style="text-align: center">Level</th></tr></thead><tbody>
<tr><td style="text-align: left">Lower Mississippi</td><td style="text-align: center">1</td><td style="text-align: right">7</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: left">Upper Mississippi</td><td style="text-align: center">2</td><td style="text-align: right">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: left">Missouri</td><td style="text-align: center">3</td><td style="text-align: right">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: left">Arkansas</td><td style="text-align: center">4</td><td style="text-align: right">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: left">Red</td><td style="text-align: center">5</td><td style="text-align: right">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: left">Ohio</td><td style="text-align: center">6</td><td style="text-align: right">2</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: left">Tenessee</td><td style="text-align: center">7</td><td style="text-align: right">1</td><td style="text-align: center">0</td></tr>
</tbody></table>
</div>
<p>Here the part before <code>=&gt;</code> is the column header and the part after is the template. Presence of <code>&lt;</code> or <code>&gt;</code> in the beginning of the line makes the column left or right aligned, with center aligned (<code>^</code>) by default.</p>
<!-- NOTE -->
<!-- Currently, the table template is run as a task internally. -->
<!-- ```task -->
<!-- !network load_file("./data/mississippi.net") -->
<!-- !network table_to_markdown(template=" -->
<!-- <Name => {_NAME:repl(-, ):case(title)} -->
<!-- >Ind => {INDEX} -->
<!-- ^Index +1 => =(+ (st+num 'INDEX) 1) -->
<!-- !") -->
<!-- ``` -->
<p>Exporting the table in svg instead of markdown allows us better
network diagram.</p>
<pre><code class="language-table"><span class="boring">network load_file("./data/mississippi.net")
</span><span class="boring">network echo("../output/example-table2.svg")
</span>&lt;Name =&gt; {_NAME:repl(-, ):case(title)}
^Ind =&gt; =(+ (st+num 'INDEX) 1)
&gt;Order =&gt; {ORDER}
^Level =&gt; {LEVEL}
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">network function: "table_to_svg" not found
</code></pre>
<p>A SVG Table can also be generated using the table file, using the task system like this:</p>
<pre><code class="language-task"><span class="boring">network load_file("./data/mississippi.net")
</span>network table_to_svg(
	table = "./data/sample.table",
	# either table = "path/to/table", or template = "table template"
	outfile = "./output/example-table.svg",
	config = {fontsize = 16, delta_y = 20, fontface="Noto Serif"}
)
<span class="boring">network clip()
</span><span class="boring"># the link path needs to be relative to this file
</span><span class="boring">network echo("../output/example-table.svg")
</span>
</code></pre>
<p>*Error*:</p>
<pre><code class="language-error">network function: "table_to_svg" not found
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-templates"><a class="header" href="#file-templates">File Templates</a></h1>
<p>File templates are templates that use string templates, but they are a whole file that can be used to generate rendered text files.</p>
<p>File templates also have sections which can be repeated for different nodes, with corresponding syntax.</p>
<p>Following template will render a markdown table with headers and all the name and index of the nodes.</p>
<pre><code class="language-stp">| Node | Index |
|------|-------|
&lt;!-- ---8&lt;--- --&gt;
| {_NAME} | {INDEX} |
&lt;!-- ---8&lt;--- --&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tasks"><a class="header" href="#tasks">Tasks</a></h1>
<p>Task is a function call that the system performs. The function call
can be a node function or a network function. The function can have
arguments and keyword arguments that can determine its
functionality. Node functions will be called on a node at a time,
while the network function will be called with the whole network at
once.</p>
<p>Currently tasks are performed one after another. The functions that
any task can use can be internal functions provided by the library or
the external functions provided by the plugins.</p>
<p>A sample tasks file is shown below:</p>
<pre><code class="language-task">node print_attrs()
network save_graphviz("/tmp/test.gv", offset=1.3, url="{_NAME}")
node savedss(
	"natural",
	"test.dss",
	"/OHIO-RIVER/{_NAME}/01Jan1994/01Jan2012/1Day/NATURAL/"
	)
node check_sf("sf")
node.inputsfirst route_sf("observed")
node render("Node {NAME} at index {INDEX}")
</code></pre>
<p>Here each line corresponds to one task. And if it’s a node task, then
it’ll be called for each node (in sequential order by default). The
last line <code>node.inputsfirst</code> will call that function in input node
before the current node. Those functions can only be called for
network with an output node.</p>
<div class="warning">
<p>Please note that although the string in the examples are highlighted
as if they are string templates for readability. Those are just normal
strings that functions take as inputs. Whether they are used as
template or not depends on the individual function, refer to their
help to see if they take <code>Template</code> type or <code>String</code> type.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-functions-14"><a class="header" href="#node-functions-14">Node Functions</a></h1>
<p>Node functions are functions that take a node, and the function
context to do some operations on it. They take mutable reference to
the node, hence can read all node attributes, inputs, outputs, their
attributes and timeseries.</p>
<p>Node functions can be run from the system for all the nodes in the
network in different orders.</p>
<p>Currently the task system only supports running node functions for all
nodes in the following 6 ways,</p>
<ul>
<li>Sequential order,</li>
<li>Reverse order,</li>
<li>Run input nodes before the current node (recursively),</li>
<li>Run output node before the current node (recursively),</li>
<li>Run a list of nodes, and</li>
<li>Run on a path between two nodes (inclusive).</li>
</ul>
<p>Depending on the way the function works, it might be required to be
run in a particular order. For example, a function that counts the
number of dams upstream of each point, might have to be run inputs
first, so that you can cumulate the number as you move downstream.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-functions-19"><a class="header" href="#network-functions-19">Network Functions</a></h1>
<p>Network functions are functions that take the network as a mutable
reference and run on it.</p>
<p>Some examples of network functions:</p>
<ul>
<li>List all the networks with their inputs/outputs,</li>
<li>Checks if any nodes have some attribute larger than their output,</li>
<li>Export the node attributes as a single CSV file,</li>
<li>Export the nodes in LaTeX file using Tikz to draw the network,</li>
<li>Calculate rmse,mse,etc errors between two attribute values for all nodes,</li>
<li>Generate an interactive HTML/PDF with network information and some other template, etc.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-notes"><a class="header" href="#developer-notes">Developer Notes</a></h1>
<p>This section contains my notes as I develop the NADI system. Kind of
like a dev blog.</p>
<p>The software package will consists of multiple components. It is
planned to be designed in such a way that users can add their
functionality and extend it with ease.</p>
<p>Along with the Free and Open Source Software (FOSS) principles, the
plugin system will make extension of the software functionality and
sharing between users. As well as a way to develop in-house
functionality for niche use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>As Hydrologist, we often deal with the data related to the points in
the river. Since most of the analysis requires doing the same things
in multiple points, the initial phase of data cleaning process can be
automated.</p>
<p>We spend a beginning phases of all projects preparing the data for
analysis. And combining the time spent on visualizing the data, it’s a
significant chunk of our time.</p>
<p>Data visualization influences the decision making from the
stakeholders. And can save time by making any problems obvious from
the very beginning. For examples, things like showing the quality of
data (continuity for time series), interactive plots to compare data
in different locations/formats, etc can help people understand their
data better.</p>
<p>Besides plot, the example below shows how simply adding a column with
connection visual can immediately make it easier to understand the
relationship between the data points in a river. Without it people
need to be familiar with the names of the data points and their
location, or consult a different image/map to understand the
relationship.</p>
<p><img src="notes/../images/ohio-low.svg" alt="Table with Connection Information" title="The table shows how a simple addition of the connection information can increase the readability of the table" /></p>
<p>The inspiration on making this software package comes from many years
of struggle with doing the same thing again and again in different
projects like these. And the motivation to make something generic that
can be used for plethora of projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h1>
<p>Rust<sup class="footnote-reference" id="fr-fn1-1"><a href="#footnote-fn1">1</a></sup> is an open source programming language that claims to be fast and memory efficient to power performance critical services. Rust is also able to integrate with other programming languages.</p>
<p>Rust provides a memory safe way to do modern programming. The White
House has a recent press
release<sup class="footnote-reference" id="fr-fn2-1"><a href="#footnote-fn2">2</a></sup>
about the need to have memory safe language in future softwares. The
report<sup class="footnote-reference" id="fr-fn3-1"><a href="#footnote-fn3">3</a></sup>
has following sentense about the Rust language.</p>
<div class="right">
At this time, the most widely used languages that meet all three
properties are C and C++, which are not memory safe programming
languages. Rust, one example of a memory safe programming language,
has the three requisite properties above, but has not yet been proven
in space systems.
</div>
<p>The results of the survey from
stackoverflow<sup class="footnote-reference" id="fr-fn4-1"><a href="#footnote-fn4">4</a></sup>
shows Rust has been a top choice for developers who want to use a new
technology for the past 8 years, and the analysis also shows Rust is a
language that generates for desire to use it once you get to know.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-fn1">
<p>https://www.rust-lang.org/ <a href="#fr-fn1-1">↩</a></p>
</li>
<li id="footnote-fn2">
<p>https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/ <a href="#fr-fn2-1">↩</a></p>
</li>
<li id="footnote-fn3">
<p>https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf <a href="#fr-fn3-1">↩</a></p>
</li>
<li id="footnote-fn4">
<p>https://survey.stackoverflow.co/2023/#technology-admired-and-desired <a href="#fr-fn4-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="writing-this-book"><a class="header" href="#writing-this-book">Writing this Book</a></h1>
<p>I’m used to <code>emacs</code>’s <code>org-mode</code>, where you can evaluate code and show
output and all those things. Like <code>markdown</code> in steroids.</p>
<p><code>mdbook</code> seems to have some of those functionality in it as
well. Though I think <code>emacs</code>’s extension through <code>elisp</code> is lot more
flexible and easier to extend. <code>mdbook</code> supporting custom
preprocessors and renderer means we can extend it as well.</p>
<p>In the process of writing this book. I made the following things.</p>
<h2 id="syntax-highlight-for-nadi-specific-syntax"><a class="header" href="#syntax-highlight-for-nadi-specific-syntax">Syntax Highlight for NADI specific syntax</a></h2>
<p><code>mdbook</code> uses <code>highlight.js</code> to syntax highlight the code blocks in
it. And since nadi system has a lot of its own syntax for string
templates, task system, table system, network system etc. I wanted
syntax highlight for those things. Although the attribute files are
subset of <code>TOML</code> format, so we have syntax highlight for
it. Everything else needed a custom code.</p>
<p>Following the comments in this <a href="https://github.com/rust-lang/mdBook/issues/657">github
issue</a> led me to find
a workaround for the custom syntax hightlight. I don’t know for how
long it will work, but this works well for now.</p>
<p>Basically I am using the custom JS feature of <code>mdbook</code> like:</p>
<pre><code class="language-toml">[output.html]
additional-js = ["theme/syntax-highlight.js"]
</code></pre>
<p>To insert custom highlight syntax. For example adding the syntax
highlight for network text is:</p>
<pre><code class="language-js">// network connections comments and node -&gt; node syntax
hljs.registerLanguage("network", (hljs) =&gt; ({
    name: "Network",
    aliases: [ 'net' ],
    contains: [
	hljs.QUOTE_STRING_MODE,
	hljs.HASH_COMMENT_MODE,
	{
	    scope: "meta",
	    begin: '-&gt;',
	    className:"built_in",
	},
    ]
}));
</code></pre>
<p>The syntax for network is really simple, for others (<code>task</code>, <code>table</code>,
<code>string-template</code>, etc) refer to the <code>theme/syntax-highlight.js</code> file
in the repository for this book.  <!-- TODO add link --></p>
<p>After registering all the languages, you re-initialize the <code>highlight.js</code>:</p>
<pre><code class="language-js">hljs.initHighlightingOnLoad();
</code></pre>
<h2 id="mdbook-nadi-preprocessor"><a class="header" href="#mdbook-nadi-preprocessor"><code>mdbook-nadi</code> preprocessor</a></h2>
<p>Instead of just showing the syntax of how to use the task system, I
wanted to also show the output of the examples for readers. So I
started this with writing some <code>elisp</code> code to run the text in
selection and then copying the output to clipboard that I could paste
in output block. It was really easy in emacs.</p>
<p>Following code takes the selection, saves them in temporary tasks file, runs them and then puts the output in the clipboard that I can paste manually.</p>
<pre><code class="language-elisp">(defun nadi-run-tasks (BEG END)
  (interactive "r")
  (let ((tasks-file (make-temp-file "tasks-")))
    (write-region BEG END tasks-file)
    (let ((output '(shell-command-to-string (format "nadi %s" tasks-file))))
	  (message output)
	  (kill-new output)
	  (delete-file tasks-file))))
</code></pre>
<p>But this is manual process with a bit of automation. So I wanted a
better solution, and that’s where the <code>mdbook</code> preprocessor comes in.</p>
<p>With the <code>mdbook-nadi</code> preprocessor, I can extract the code blocks,
run it, and insert the contents just below the code block as output.</p>
<p>Once I had a working prototype for this, I also started adding support
for rendering string templates, and generating tables along with the
task system.</p>
<h3 id="string-templates-2"><a class="header" href="#string-templates-2">String templates</a></h3>
<p>For string templates, write the templates in <code>stp</code> blocks like below that will have the syntax hightlight.</p>
<pre><code class="language-stp">Hi my name is {name}.
</code></pre>
<p>If you add <code>run</code> into it, it’ll run the template with any <code>key=val</code> pairs provided after run.</p>
<p>Basically writing the following in the <code>mdbook</code> markdown:</p>
<pre><code>```stp run name=John
Hi my name is {name}.
```
</code></pre>
<p>Will become:</p>
<hr />
<pre><code class="language-stp">Hi my name is {name}.
</code></pre>
<p>Results (with:  name=John):</p>
<pre><code class="language-output">Hi my name is John.
</code></pre>
<hr />
<h3 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h3>
<p>For tasks, similary write a block with <code>task</code> as language. You can use
<code>!</code> character at the start of the line to hide it in the view. Use
them for essential code that are needed for results but are not the
current focus. And when you add <code>run</code> it’ll run and show the output.</p>
<pre><code>```task run
!network load_file("data/mississippi.net")
node render("Node {NAME}")
```
</code></pre>
<hr />
<pre><code class="language-task"><span class="boring">network load_file("data/mississippi.net")
</span>node render("Node {NAME}")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">{
  lower-mississippi = "Node \"lower-mississippi\"",
  upper-mississippi = "Node \"upper-mississippi\"",
  missouri = "Node \"missouri\"",
  arkansas = "Node \"arkansas\"",
  red = "Node \"red\"",
  ohio = "Node \"ohio\"",
  tenessee = "Node \"tenessee\""
}
</code></pre>
<hr />
<h3 id="tables-1"><a class="header" href="#tables-1">Tables</a></h3>
<p>The implementation for tables are little weird right now, but it works. Since we need to be able to load network, and perform actions before showing a table.</p>
<p>So the current implementation takes the hidden lines using <code>!</code>and runs them as task system, with additional task of rendering the table at the end.</p>
<p>Example:</p>
<pre><code>```table run markdown
!network load_file("./data/mississippi.net")
&lt;Name =&gt; {_NAME:repl(-, ):case(title)}
^Ind =&gt; =(+ (st+num 'INDEX) 1)
&gt;Order =&gt; {ORDER}
```
</code></pre>
<p>Becomes:</p>
<hr />
<pre><code class="language-table"><span class="boring">network load_file("./data/mississippi.net")
</span>&lt;Name =&gt; {_NAME:repl(-, ):case(title)}
^Ind =&gt; =(+ (st+num 'INDEX) 1)
&gt;Order =&gt; {ORDER}
</code></pre>
<p>Results:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Ind</th><th style="text-align: right">Order</th></tr></thead><tbody>
<tr><td style="text-align: left">Lower Mississippi</td><td style="text-align: center">1</td><td style="text-align: right">7</td></tr>
<tr><td style="text-align: left">Upper Mississippi</td><td style="text-align: center">2</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">Missouri</td><td style="text-align: center">3</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">Arkansas</td><td style="text-align: center">4</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">Red</td><td style="text-align: center">5</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">Ohio</td><td style="text-align: center">6</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">Tenessee</td><td style="text-align: center">7</td><td style="text-align: right">1</td></tr>
</tbody></table>
</div>
<hr />
<p>I’d like to refine this further.</p>
<p>Task can be used to generate markdown in the same way as the tables
can:</p>
<p>For example <code>task run</code> of this:</p>
<pre><code class="language-task">network load_file("./data/mississippi.net")
network table_to_markdown(template="
&lt;Name =&gt; {_NAME:repl(-, ):case(title)}
^Ind =&gt; =(+ (st+num 'INDEX) 1)
&gt;Order =&gt; {ORDER}
")
</code></pre>
<p>Results:</p>
<pre><code class="language-output">| Name              | Ind | Order |
|:------------------|:---:|------:|
| Lower Mississippi |  1  |     7 |
| Upper Mississippi |  2  |     1 |
| Missouri          |  3  |     1 |
| Arkansas          |  4  |     1 |
| Red               |  5  |     1 |
| Ohio              |  6  |     2 |
| Tenessee          |  7  |     1 |
</code></pre>
<p>If you do <code>task run markdown</code> then:</p>
<pre><code class="language-task">network load_file("./data/mississippi.net")
network table_to_markdown(template="
&lt;Name =&gt; {_NAME:repl(-, ):case(title)}
^Ind =&gt; =(+ (st+num 'INDEX) 1)
&gt;Order =&gt; {ORDER}
")
</code></pre>
<p>Results:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Ind</th><th style="text-align: right">Order</th></tr></thead><tbody>
<tr><td style="text-align: left">Lower Mississippi</td><td style="text-align: center">1</td><td style="text-align: right">7</td></tr>
<tr><td style="text-align: left">Upper Mississippi</td><td style="text-align: center">2</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">Missouri</td><td style="text-align: center">3</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">Arkansas</td><td style="text-align: center">4</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">Red</td><td style="text-align: center">5</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">Ohio</td><td style="text-align: center">6</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">Tenessee</td><td style="text-align: center">7</td><td style="text-align: right">1</td></tr>
</tbody></table>
</div>
<p>Which means it can be used for other things:</p>
<pre><code class="language-task">network load_file("./data/mississippi.net");
network echo("**Details about the Nodes:**")
network echo(render_nodes("
=(+ (st+num 'INDEX) 1). {_NAME:repl(-, ):case(title)} River
"))
</code></pre>
<p>Results:<br />
<strong>Details about the Nodes:</strong></p>
<ol>
<li>
<p>Lower Mississippi River</p>
</li>
<li>
<p>Upper Mississippi River</p>
</li>
<li>
<p>Missouri River</p>
</li>
<li>
<p>Arkansas River</p>
</li>
<li>
<p>Red River</p>
</li>
<li>
<p>Ohio River</p>
</li>
<li>
<p>Tenessee River</p>
</li>
</ol>
<p>You can also use the same method to insert images like this, at the end of your tasks, so that the image generated by the tasks can be inserted here.</p>
<pre><code class="language-task"># do some tasks
network echo("Some other output form your tasks")
network clip()
network echo("../images/ohio-low.svg")
</code></pre>
<p>Results:</p>
<center>  
<p><img src="notes/../images/ohio-low.svg" alt="" /></p>
</center>  
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimization-algorithms"><a class="header" href="#optimization-algorithms">Optimization Algorithms</a></h1>
<p>We can have input variables to change, and output variables to
optimize, but how do we take what function to run to calculate the
output variable…</p>
<p>One simple idea can be to take a command template to run. So we will
change the input variables, run the command for each node or network,
and then that command will update the output variable that we can
optimize for.</p>
<p>We might require an option to call other functions in
this case. Then maybe we can just pass the name of the function.</p>
<p>Complex idea could be to add the support for loop syntax in task system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interactive-plots"><a class="header" href="#interactive-plots">Interactive Plots</a></h1>
<p>An experiment using the <code>cairo</code> graphics library shows that a PDF can
be directly produced without using LaTeX as intermediate using the
network information. This functionality — although not as complete
as the one in the example — has been exposed as an internal network
function for now. Further functionality related to this idea can be
embedding network information in simple plots, or generate the whole
plot along side the network information.</p>
<p>It might be a good idea to make several functions that can export the interactive plots in LaTeX, PDF, PNG, SVG, HTML, etc. separately instead of single format.</p>
<p>LaTeX and HTML will be easier due to text nature, for others I might have to spend time with some more experimentation on cairo.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/syntax-highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
